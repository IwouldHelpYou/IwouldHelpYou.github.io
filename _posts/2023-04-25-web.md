# 웹개발일지

[[스파르타코딩클럽] 웹개발 종합반 - FAQ](https://www.notion.so/FAQ-9a10bc3536ea404d9d76bdb5c3f0d14f) 

부트스트랩(CSS모음) 링크 : [https://getbootstrap.com/docs/5.2/components/card/](https://getbootstrap.com/docs/5.2/components/card/)

구글 폰트 링크 : [https://fonts.google.com/](https://fonts.google.com/)

- **꿀팁 단축키**
    
    코드 정렬 : Ctrl+Alt+L
    
    들여쓰기 : Tap ↔ 들여쓰기 취소 : Shift + Tap
    
    주석 : Ctrl+/
    
- **꿀팁 콘솔**
    - F12 누르면 바로감!!
    - 콘솔 검사한다음 모바일텝 누르면 모바일에서 어떻게 보이는지 확인가능
    - 콘솔에서 javascript 수정가능하다
    - 콘솔에서 console.log(’’) 하면 직접 창 띄우는게 아니고 콘솔창에 남기는것
    - 금지표시 누르면 없어짐
- **꿀팁 오류**
    
    -python 오류시 줄 맞췄나 확인
    -python return 하면 함수종료임. 이후에 뭐 쓰면 안먹힘
    -javascript function들 순차실행인듯. 위에함수 작동안되면 아래것들도 안됨
    flask 로 서버만들면 실행해야함. 그냥 html처럼 저장만하면 업뎃안됨
    
    -JSX 문법 쓸때? <button onClick={alert(’hi’)}> 이런식으로하면 오류나더라 밖에 함수선언해서 안에서 콜해야함 
    
    -JSX 문법쓸때 <button onClick={handlerClearClick()}> 이렇게쓰면 그냥 랜더시바로실행됨. <button onClick={()⇒{handlerClearClick();}
    이렇게 쓰거나 <button onClick={function() {handlerClearClick(); } 이케써야
    
    -컴포넌트로 만든 버튼에서 onClick 을 쓰고 싶다면, 하위 버튼 컴포넌트에서 이를 정의해주어야한다. 아래와같이 기본태그 button을 클릭했을 때 handleClick 이 동작하게 하여서 이 함수 내부에서 prop 으로 받은 onClick 이 실행되게 해야함
    
    ```
    function HandButton({value,onClick}) {
        const pae=['rock','scissor','paper']
    
        const handleClick = () => {
            onClick();
            alert(pae[value]);
        }
        //const handleClick = () => onClick(value);
    
        return (
        <>
        <button onClick={handleClick}> **<- 요기 onClick 이랑 컴포넌트 onClick 이랑헷갈x**
            {/* text 왜넣었는지는 나도 모름 */}
            <HandIcon text="주사위" value={value}/> 
        </button>
        </>
        )
    }
    
    export default HandButton;
    
    ---------------------------------
    
    혹은 그냥 <button onClick={()=>onClick()}> 이래줘도 되는듯.
    **여튼 위에서 prop 으로 받은 onClick 을 따로 줘야함을 기억**
    ```
    
    -리액트에서는 값 변경하고 싶으면 무조건 setter 씀 a+=1; 이런거 안통함
    
    -**css에서 url 넣는법?** 아래 화면에서는 인라인 안하고 따로 css 만들어썼으니 camel case 안쓰는거고, 이 때 url 넣고 싶으면 따로 import 하거나 해서 쓰는게 아니고 (인라인으로하려면 import 한후 객체에 저장해서 { }요기담앗지) **backgorund-image: url(./assets/purple.svg) 이렇게씀**
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled.png)
    
- **브라우저란?**
    
    
    ![[스파르타코딩클럽] 웹개발 종합반 - 1주차 강의노트중](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%201.png)
    
    [스파르타코딩클럽] 웹개발 종합반 - 1주차 강의노트중
    
    우리가 보는 웹페이지는 모두 서버에서 미리 준비했던 것을 받아서 그려주는것입니다.
    
    크롬, 익스플로러 등으로 대표되는 브라우저란 1) (서버에 있는 api 창구에) 요청을 보내고 2)받은 HTML파일을 그대로 보여주는 것입니다.
    
    (https://[naver.com](http://naver.com)/ 이라고 하면 naver.com 이라는 이름의 서버에 있는 “/” 창구에 요청을 보낸 것)
    
    F5를 통해 새로고침하면 창이 바뀌게 되는데 ‘새로’ 받아온다는 의미입니다.
    
    이 때 뭘 받아올 것이냐?
    HTML CSS Javascript 
    
    HTML 은 홈페이지 전체 골격, CSS는 꾸미기, Javascript 는 움직이기 이렇게 이해할 수 있습니다.
    
    ![[스파르타코딩클럽] 웹개발 종합반 - 1주차 강의노트중](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%202.png)
    
    [스파르타코딩클럽] 웹개발 종합반 - 1주차 강의노트중
    
    항상 HTML을 받아오는 것은 아닙니다
    
    가령 공연티켓 예매할 때 좌석이 차고 꺼질때마다 페이지가 리프레시 되는 것은 않죠
    
    이럴 때는 위와 같이 데이터만 받아서 받아 끼우게 됩니다.
    

npm : 패키지를 관리하는 프로그램(설치 or 삭제)

패키지 : 자바스크립트 모듈을 모아놓은 묶음. 패키지를 설치하면 미리 작성된 JS모듈 갖다씀
(react와 react-dom 도 패키지)

- JSX 문법 (React)
    
    JavaScript의 모든 기능이 포함되어 있습니다.JSX는 React “엘리먼트(element)” 를 생성합니다. 다음 섹션에서는 DOM에 어떻게 렌더링하는지 알아보겠습니다. 
    
    JSX의 중괄호 안에는 유효한 모든 JavaScript 표현식을 넣을 수 있습니다
    
    JSX도 표현식입니다컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식됩니다.
    즉, JSX를 if 구문 및 for loop 안에 사용하고, 변수에 할당하고, 인자로서 받아들이고, 함수로부터 반환할 수 있습니다.
    
    {Value}
    
- Javascript 문법 (ES6)
    
    ES6부터 제공하는 템플릿 리터럴은 이중 따옴표("")나 작은 따옴표('') 대신 백틱( )(grave accent)을 이용합니다.
    
    ```jsx
    <Link to="/questions/616825">{question.title}</Link>
    {/* 요기에다가 616825 대신 question.id 를 박고싶다면...? */}
     
    <Link to={`/questions/${question.id}`}>{question.title}</Link>
    ```
    
    # 템플릿 리터럴의 기능
    
    - 1. Arrow function
        
        <aside>
        👉 let a = function( ) { 함수내용; } 
        요런애들
        
        let a = ( ) ⇒ { 함수내용; }
        이렇게 축약가능
        
        </aside>
        
        ```jsx
        function add(a, b) {
          return a + b;
        }
        
        이상 Function Declaration (함수선언식)이라함
        
        const add = function(a, b) {
          return a + b;
        };
        
        이상 Function Expression (함수 표현식)이라함
        
        const add = (a, b) => { 
          return a + b;
        };
        
        Function Expression은 위의 방법으로 표현도 가능
        ```
        
        ```jsx
        const arr = [1, 2, 3, 4, 5];
        
        function getSquare(x) {
          return x * x;
        }
        
        const newArr = arr.map(getSquare);
        console.log(newArr);
        
        -----------------
        
        const arr = [1, 2, 3, 4, 5];
        
        const newArr = arr.map(function(x) {
          return x * x;
        });
        
        console.log(newArr);
        
        ------------------ getSquare 라는 함수를 별도 선언하지않고도 가능 ----- 
        이를 Anonymous Function 익명함수라고 함---------------
        
        const arr = [1, 2, 3, 4, 5];
        
        const newArr = arr.map((x) => {
            return x * x;
        });
        
        console.log(newArr);
        
        ------------------ Anonymous Function을 화살표로 나타낼 수도 있고~~ -----
        
        ```
        
    
    2. 줄바꿈(개행: Multi-line strings) 
    ▶︎ 백틱(`)으로 템플릿 리터럴을 사용하면, 줄바꿈 등을 쉽게 표현할 수 있다.
    var str_01 = `Hi!    It's me!             JavaScript!So Cool!`;
    
    ▶︎ 기존 따옴표 방식에서는 줄바꿈이 허용되지 않았기 때문에,
    ▶︎ 백슬러시(\)로 시작하는 이스케이프 시퀀스를 사용해야 했다.
    var str_01 = "Hi! \n\t It's me! \n\t\t\t JavaScript! \n So Cool!";* \n은 개행(Line Feed), \t는 탭(수평)을 의미하는 이스케이프 시퀀스
    
    3. 표현식 삽입(Expression interpolation)
    ▶︎ ${ } 사이에 변수나 연산 등을 삽입할 수 있게 되었다.
    var name = `사과`var price = 100var num = 5;
    console.log(`${name}의 구매가는 ${price * num}원 입니다.`) 
    
    * ${ } 의 결과는 문자열로 자동 변환됨.
    
    ▶︎ 기존의 따옴표 방식에서는, + 연산자로 여러번 이어 붙여야 했다.
    var name = `사과`var price = 100var num = 5;
    console.log(name + "의 구매가는 " + (price * num) + "원 입니다");
    
    또한 플레이스 홀더를 이용하여 표현식을 넣을 수 있는데, 이는 $와 중괄호를 이용하여 ${expression} 다음과 같이 표현합니다. 백틱 안에 백틱을 넣어야 할때는 백틱 앞에 백슬러시\를 붙여줍니다.
    
    [**함수축약**](https://www.notion.so/9ab67a7d2b004316b9ddb43770cc773d)
    

- 리액트 훅
    
    # **훅(Hook)이란?**
    
    Hook은 리액트 16.8 버전 이후 추가된 기능이며, Hook이 등장하면서 더 이상 상태를 관리하기 위해 Class를 쓸 필요가 없어졌다. 기존에는 Class형 컴포넌트에서만 상태를 관리 할 수 있었고, 함수형 컴포넌트에서는 상태를 관리할 수 없었지만, Hook을 통해 상태 관리를 할 수 있게 되었고, 상태 관리 뿐만 아니라 기존 클래스형 컴포넌트에서만 가능하던 여러 기능을 사용할 수 있게 되었다.
    
    **Hook이 등장하기 전 리액트에는 여러 문제들이 있었다.**
    
    *
    
    React 컴포넌트가 화면에 1차로 렌더링된 이후에 비동기로 처리되어야 하는 부수적인 효과들을 흔히 Side Effect라고 한다.
    
    예를들어 데이터를 가져오려고 외부 API를 호출할 때, 일단 화면에 렌더링할 수 있는 것은 1차로 먼저 렌더링하고 실제 데이터는 비동기로 가져오는 것이 권장된다. 왜 먼저 렌더링하냐면 연동된 API가 응답이 늦거나 없을 때 데미지(~~답답함)~~을 최소화 시켜 사용자 경험 측면에서 유리하기 때문이다.
    
    → 한마디로 요구되어지는 이펙트 이외에 다른 이펙트가 발생하는 현상이라고 생각하면 된다.
    
    → Hook은 이 side effect 를 수행하는역할을 한다. side effect 를 줄여 그냥 effect 라고 한다. 그래서 훅의 이름은 useEffect 가 된다.
    
    # **탄생배경**
    
    리액트 컴포넌트는 **클래스형 컴포넌트(Class component)**와 **함수형 컴포넌트(Functional component)**로 나뉜다.
    
    기존의 개발방식은 일반적으로 함수형 컴포넌트를 주로 사용하되 
    
    state이나 Life Cycle Method를 사용해야 할 때에만 **클래스형 컴포넌트를 사용하는 방식**이었다.
    
    이유는 클래스형 컴포넌트가 함수형 컴포넌트에 비해 가지는 단점 때문.
    
    - 클래스 문법이 어렵다.
    - 클래스는 축소가 어렵다.
    - Logic의 재사용이 어렵다 (this 의 사용이나 이벤트 핸들러 등록 등 JS 문법사항알아야함)
    - react 의 최신 기술의 클래스형 컴포넌트에 적용이 효과적이지 않다.
    
    그래서 **함수형 컴포넌트**를 쓰는데…
    
    함수형 컴포넌트 클래스 컴포넌트의 장점인 state 나 life cycle의 기능을 사용하기 어려웠음
    
    그래서 훅이 등장!!
    
    **Hook 은 함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용하게 해줌!!**
    
    **useState 나 useEffect 를 사용하면 기존 클래스 컴포넌트 기능이었던 state 나 lifecycle 같은 기능을 사용할 수 있다.**
    
    State Hook - useState
    
    Effect Hook - useEffect
    
    # **종류**
    
    ### 기본 Hooks
    
    1. useState (동적 상태 관리)
    2. useEffect (side effect 수행 -mount/unmount/update)
    3. useContext (컴포넌트를 중첩하지 않고도 전역 값 쉽게 관리)
    
    ### 추가 Hooks
    
    1. useReducer (복잡한 컴포넌트들의 state를 관리 -분리)
    2. useCallback (특정 함수 재사용)
    3. useMemo (연산한 값 재사용)
    4. useRef (DOM선택, 컴포넌트 안에서 조회/수정할 수 있는 변수 관리)
    5. useImperativeHandle
    6. useLayoutEffect
    7. useDebugValue
    
    # **장점**
    
    - 코드가 간결해진다.
    - 가독성이 좋아진다.
    - 많은 라이브러리들도 훅으로만 나오고 있다.
    - HOC 헬을 벗어 날 수 있다.
    - 불필요한 것 같은 코드를 적을 필요가 없다.
    
- 리액트 커스텀훅
    
    컴포넌트 내부에서 훅을 사용해 로직을 구현하다보면 중복되는 부분이 발생하게 됨
    
    Hook 을 추상화된 로직으로 사용할 수 있도록 결합해주고
    
    다른 컴포넌트 사이에서 공통 상태 관련 로직을 재사용할 수 있게 해주는 것이 커스텀훅
    
    컴포넌트에서 사용되는 훅 관련된 로직을 추상화하고 분리하여 재사용할 수 있게 해주는 것
    
    ---
    
    예를들어 회원가입 폼을 구현하다보면 여러 개의 input 을 staste 로 관리해주어야 하는데 
    
    이 input 들의 onChange 핸들러를 모두 작성해주어야한다.
    
    ```jsx
    import { useState } from 'react';
    
    function MainPage() {
      const [username, setUsername] = useState('');
      const handleUsername = (e) => setUsername(e.target.value);
    
      const [password, setPassword] = useState('');
      const handlePassword = (e) => setPassword(e.target.value);
    
      const [email, setEmail] = useState('');
      const handleEmail = (e) => setEmail(e.target.value);
      
      return (
        <main className="container">
          <div className="header">Welcome, 👋</div>
          
          <hr />
    
          <label htmlFor="username">이름</label>
          <input type="text" id="username" value={username} onChange={handleUsername} />
    
          <hr />
    
          <label htmlFor="email">이메일</label>
          <input type="email" id="email" value={email} onChange={handleEmail} />
    
          <hr />
    
          <label htmlFor="password">비밀번호</label>
          <input type="password" id="password" value={password} onChange={handlePassword} />
    
          <hr />
    
          
        </main>
      );
    }
    
    export default MainPage;
    ```
    
    여기서 공통된 부분을 추출하여 useInput 이라는 커스텀 훅을 만들어보자
    
    ```jsx
    import { useState } from 'react'
    
    function useInput() {
      const [value, setValue] = useState('');
      const onChange = (e) => setValue(e.target.value);
      
      return { value, onChange };
    }
    
    export default useInput;
    ```
    
    ```jsx
    import useInput from '@/core/useInput';
    
    function MainPage() {
    
      const username = useInput();
      const password = useInput();
      const email = useInput();
      
      return (
        <main className="container">
          <div className="header">Welcome, 👋</div>
          
          <hr />
    
          <label htmlFor="username">이름</label>
          <input type="text" id="username" {...username} />
    
          <hr />
    
          <label htmlFor="email">이메일</label>
          <input type="email" id="email" {...email} />
    
          <hr />
    
          <label htmlFor="password">비밀번호</label>
          <input type="password" id="password" {...password} />
    
          <hr />
    
          
        </main>
      );
    }
    
    export default MainPage;
    ```
    
    자!  훨씬 간결해졌다.
    
    ***useInput*** 의 반환 값이 `{ value, onChange }` 이기 때문에 ***props-spreading*** 을 통해 손쉽게 input에게 props를 넘겨줄 수 있다.
    
    > 이렇게 props-spreading을 사용해 props를 전달하는 것은 다음의 이유로 인해 권장되는 방식은 아니다.
    > 
    > 
    > *커스텀 훅을 사용하면 이렇게 간결해질 수 있다*
    > 

### HTML

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%203.png)

tree 구조에서 root 노드(최상위 노드) 를 포함한 모든 개개의 개체를 node라고 표현. 

head, body, title, script, h1, HEADER-1 등의 태그뿐 아니라 태그 안의 텍스트나 속성 등도 모두 node에 속함

이중 HTML 태그를 요소노드(Element Node)라고 부르고 

요소 노드 안에 있는 글자를 Text 노드(Text Node)라고 부르기도 함

---

- **HTML 사용법 (예제코드 有)**
    
    
    기본적으로 html은 head 와 body로 구성됩니다. 
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
    
    	<head>
    		<meta charset="UTF-8">
    		<meta name="viewport" content="width=device-width, initial-scale=1.0">
    		<title>개발일지</title>
    	</head>
    
    	<body>
    		<h1>h1은 제목을 나타내는 태그입니다
    	</body>
    
    </html>
    ```
    
    - head
    
    head에는 여러가지 용도가 있는데 
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%204.png)
    
    우선 <title> ~</title> 은 웹페이지 위에 뜨는 위와 같은 것들을 의미합니다.
    
    - body
    
    일반적으로 body는 지금 보시는 공간에 뜨는 모든 것들을 의미한다고 보시면 됩니다.
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
    	<head>
    	<meta charset="UTF-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    	<title>스파르타코딩클럽 | 로그인페이지</title>
    
    	</head>
    
    	<body>
    		<div class="wrap">
    		<div class="mytitle">
    		<h1>로그인 페이지</h1>
    		<h5>아이디, 비밀번호를 입력해주세요</h5>
    		</div>
    		<div>
    		<p>
    		ID: <input type="text" />
    		</p>
    		<p>
    		PW: <input type="password" />
    		</p>
    		</div>
    		<button>로그인하기/button>
    		</div>
    		</body>
    	</body>
    
    	</html>
    ```
    
    위의 코드를 입력하면 아래와 같은 화면이 나타나게 됩니다.
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%205.png)
    
    html 은 “누가 누구 안에 있느냐”를 이해하는 것이 중요합니다. 
    
    감싸고 있는 태그가 바뀌면 내용물도 모두 영향을 받기 때문입니다.
    
- **HTML 태그 모음집**
    
    **소개한 것**
    
    ```html
    <!-- 구역을 나누는 태그들 -->
    <div>나는 구역을 나누죠</div>
    <p>나는 문단이에요</p>
    <ul>
    <li> bullet point!1 </li>
    <li> bullet point!2 </li>
    </ul>
    <!-- 구역 내 콘텐츠 태그들 -->
    <h1>h1은 제목을 나타내는 태그입니다. 페이지마다 하나씩(만) 꼭 써주는 게 좋아요. 그래야 구글 검색이 잘 되거든요.</h1>
    <h2>h2는 소제목입니다.</h2>
    <h3>h3~h6도 각자의 역할이 있죠. 비중은 작지만..</h3>
    <hr>
    span 태그입니다: 특정 <span style="color:red">글자</span>를 꾸밀 때 써요
    <hr>
    a 태그입니다: <a href="http://naver.com/"> 하이퍼링크 </a>
    <hr>
    img 태그입니다: <img src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" />
    <hr>
    input 태그입니다: <input type="text" />
    <hr>
    button 태그입니다: <button> 버튼입니다</button>
    <hr>
    textarea 태그입니다: <textarea>나는 무엇일까요?</textarea
    ```
    
    **내가 배운것**
    
    ```html
    <br> : 줄바꿈태그
    --------------------------------------------------------------------
    <input type=”text”> 이렇게 타입지정. 
    <input> 하면 기본 text 타입
    <input> </input> 닫는태그까진 잘 안씀
    --------------------------------------------------------------------
    <ul></ul> : unordered list. 순서가 중요하지 않은 리스트
    안에 li(list item) 들을 넣고 ul로 감싸준다
    
    <ol></ol> : ordered list. 순서화된 리스트에 적합. 숫자가 알아서 붙음.
    --------------------------------------------------------------------
    <table> 
    
     <thead> 
       <tr> **// table row. 가로줄을 만든다**
         <th> </th> **// table head. 표의 제목을 쓴다**
         <th> </th>
         <th> </th>
       </tr>
     </thead> 
    
     <tbody>
       <tr> 
         <td> </td> **// table data. 표의 내용을 만든다**
         <td> </td>
         <td> </td>
       </tr>
       <tr></tr>
       <tr></tr>
     </tbody>
    
    </table>
    --------------------------------------------------------------------
    <A href="페이지"></href> : 페이지로 넘어가게 해줌
    ```
    
- **og 태그**
    
    아래 그림과 같이 카톡/페이스북/슬랙에 공유했을때 예쁘게 나오도록 하려면 og태그를 사입해야함.
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%206.png)
    
    HTML의 <head>~</head> 사이에 아래 내용을 작성하면 og 태그 사용가능.
    
    ```jsx
    <meta property="og:title" content="내 사이트의 제목" />
    <meta property="og:description" content="보고 있는 페이지의 내용 요약" />
    <meta property="og:image" content="이미지URL" />
    ```
    
    🌟 페북 카톡 등에서는 처음 og 태그를 한동안 저장해놓기 때문에 이미지를 바꿔도 og 이미지가 고정되어있을수도있다.
    
    <aside>
    👉 페이스북 og 태그 초기화 하기: [https://developers.facebook.com/tools/debug/](https://developers.facebook.com/tools/debug/)
    
    카카오톡 og 태그 초기화 하기: [https://developers.kakao.com/tool/clear/og](https://developers.kakao.com/tool/clear/og)
    
    </aside>
    

### CSS

---

- **CSS 사용법 (예제코드 有)**
    
    <aside>
    👉 CSS란?
    
    Cascading Style sheet 의 약자로 물흐르듯이 따라간다 뭐 그런뜻
    
    </aside>
    
    <aside>
    👉 **CSS 사용법**
    
    1.
    head 안에 <style> ~</style> 공간을 만듭니다. 
    
    2.
    head 안에 .mytitle{ } 로 클래스를  정의한 후 
    body 에서 <태그 class=”mytitle> 이런식으로 호출합니다. 
    
    그러면 태그안에 모든 애들이 위에서 만들어진 CSS 의 적용받아 꾸며집니다.
    
    참고로 head 안에서 .name{ } 이 아니라  *{ } 이렇게하면 모든 태그에 다 맥이는것
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
    
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>스파르타코딩클럽 | 로그인페이지</title>
        <style>
            .mytitle {
                color: white;
             }
    
            .wrap {
                margin: 10px auto;
                width: 300px;
            }
        </style>
    </head>
    
    <body>
        <div class="wrap">
            <div class="mytitle">
                <h1>로그인 페이지</h1>
                <h5>아이디, 비밀번호를 입력해주세요</h5>
            </div>
    
    			  <button>로그인하기</button>
        </div>
    </body>
    </body>
    
    </html>
    ```
    
    위와같이 <div> 태그를 이용해서 <h1>,<h2>,<button>까지 모든 태그를 묶어서 CSS를 적용하는 센스도 발휘할 수 있습니다.
    
    </aside>
    
    <aside>
    👉 **CSS 사용예시**
    
    ![<CSS 적용전 예시>](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%207.png)
    
    <CSS 적용전 예시>
    
    ![<CSS 적용후 예시>
    ](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%208.png)
    
    <CSS 적용후 예시>
    
    [FULL CODE](https://www.notion.so/FULL-CODE-ab2eaea84f6348faa340c000db8b0dd3)
    
    </aside>
    
- **CSS 모음집**
    
    <aside>
    👉 **CSS 모음집**
    
    배경
    
    background-color
    background-image
    background-size
    
    사이즈
    width
    height
    
    폰트
    font-size
    font-weight
    font-famliy
    color
    
    간격
    margin : 바깥 여백을 줍니다. 
    
    ex) 만들어둔 로그인 화면을 가운데로 가져오게 하려면 width를 주고, margin : auto를 사용합니다.
    
    padding : 안쪽 여백을 줍니다.
    
    ex) padding : 10px 10px 10px 10px 하면 상하좌우 넣는것
    ex) padding-top : 10px 하면 위에만 패딩줌
    
    </aside>
    
    <aside>
    👉 **************범규 팁**************
    
    💰
    ****************************background-image
    background-size(사이즈맞춰줌)
    background-position(가온데로맞춰줌) 얘넨 항상 붙어다님
    
    ```html
    background-image: url("https://movie-phinf.pstatic.net/20210715_95/1626338192428gTnJl_JPEG/movie_image.jpg");
    background-position: center;
    background-size: cover;
    ```
    
    💰
    
    내용물 정돈시키기 
    
    ```html
    display: flex;
    flex-direction: column;
    <!-- row 세로로 정렬 column 가로로 정렬 -->
    justify-content: center;
    align-items: center;
    ```
    
    💰
    
    ‘>’ 으로 세부적으로 수정 가능   
    
    ![head 에서 mytitle 꾸미고 button, button이 눌렸을 때 따로 꾸며줌](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%209.png)
    
    head 에서 mytitle 꾸미고 button, button이 눌렸을 때 따로 꾸며줌
    
    ![먹이게되는 body 부분](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2010.png)
    
    먹이게되는 body 부분
    
    💰 
    linear-gradient(0deg, rgba(0,0,0,0.5), rgba(0,0,0,0.5)) 
    얘네를 background url 앞에 넣어주면 배경밝기 조절한다고함
    
    💰
    box-shadow : 그림자 있는 박스 뜸
    
    💰
    보통 창을 줄이거나 키우면 같이 크기가 안바뀌고 걍 고정되어있음. 이럴 때 이렇게하면 늘렸을 때 500까지만 커지고 그 전가진 95%만 채워줌 모바일에 
    
    max-width: 500px; 
    width 95%; 
    
    (참고로 검사한 다음 모바일 탭 누르면 모바일환경에서 보임) 
    
    </aside>
    
- **CSS 팁 (폰트적용, CSS분리, div태그 활용)**
    
    <aside>
    👉 **폰트 적용법**
    
    [https://fonts.google.com/](https://fonts.google.com/)
    
    구글 폰트에서 HTML을 긁어와서
    
    HTML head 에 이 부분을 추가하고
    <link href="[https://fonts.googleapis.com/css2?family=Jua&display=swap](https://fonts.googleapis.com/css2?family=Jua&display=swap)" rel="stylesheet">
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2011.png)
    
    CSS에 이 부분을 추가하면 완성
    
    *{
    font-family: 'Jua', sans-serif;
    }
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2012.png)
    
    </aside>
    
    <aside>
    👉 **CSS 파일 분리법**
    
    <style>~</style> 부분이 너무길어진다면 보기가 어려울 것임.
    
    style.css 파일을 같은 폴더에 만들고, 
    
    head 태그에서 아래 부분을 불러오면 된다
    <link rel="stylesheet" type="text/css" href = "(css파일이름).css">
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2013.png)
    
    만든 css 파일에 <style>~</style> 들어갈 필요는 없고 내용물의 .클래스 들만 잘 정의되면 되더라
    
    </aside>
    
    <aside>
    👉 **div 이용하기**
    
    <div> 태그를 이용해서 <h1>,<h2>,<button>까지 모든 태그를 묶어서 CSS를 적용하는 센스도 발휘할 수 있습니다.
    
    ![head 의 style 에 wrap class를 정의하고](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2014.png)
    
    head 의 style 에 wrap class를 정의하고
    
    ![맥이고 싶은 태그에 div 정의하고 싹맥이면 굿](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2015.png)
    
    맥이고 싶은 태그에 div 정의하고 싹맥이면 굿
    
    </aside>
    
- 🌟 **Bootstrap (예제 코드 有) // 프레임워크임**
    
    <aside>
    👉 **부트스트랩 사용법**
    
    CSS 파일 분리에서와 방식은 비슷하다 
    
    ```html
    <!doctype html>
    <html lang="en">
    	<head>
    		<meta charset="utf-8">
    		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
    		integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
    		integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
    		crossorigin="anonymous"></script>
    		<title>스파르타코딩클럽 | 부트스트랩 연습하기</title>
    	</head>
    
    	<body>
    	<h1>이걸로 시작해보죠!</h1>
    	</body>
    </html>
    ```
    
    위와 같은 템플릿을 우선 붙여놓고
    
     
    
    부트스트랩 사이트 ([https://getbootstrap.com/docs/5.2/components/card/](https://getbootstrap.com/docs/5.2/components/card/))에서 태그들을 긁어서 body에 붙이면 된다! 
    
    </aside>
    
    <aside>
    💡 부트스트랩 사용 예시
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2016.png)
    
    [FULL CODE](https://www.notion.so/FULL-CODE-10c7d40b110e4dfbb9bce7e4b0af6a59)
    
    </aside>
    

### Javascript

---

- **Javascript** **사용법**
    
    <aside>
    👉 자바스크립트란?
    
    클라이언트가 서버에 요청하면, 서버는 클라이언트에게 HTML, CSS 와 함께 Javascript를 준다.
    
    HTML 안에 파이썬, Java 가 아닌 Javascript 언어를 써주는 이유는 모든 브라우저는 Javascript 를 알아듣도록 표준이 설정되어있기 때문임.
    
    Javascript 와 Java는 아무 관계가 없다.
    
    </aside>
    
    <aside>
    👉 **사용법**
    
    1.
    head 안에 <script> ~</script>로 공간을 만듭니다.
    
    2.
    head 의 script 안에 function name( ){  } 로 클래스를  정의한 후 
    body 에서 <태그 onclick=”name( )”> 이런식으로 호출합니다. 
    
    그러면 태그안에 모든 애들이 위에서 만들어진 CSS 의 적용받아 꾸며집니다.
    
    </aside>
    
    <aside>
    👉 ******************************콘솔창이란?******************************
    
    크롬에서 “마우스 오른쪽 클릭 → 검사 → console” 창에서 그때그때 띄워놓은 페이지에서 빠르게 자바스크립트를 테스트할 수 있습니다.
    
    * 새로고침하면 사라집니다
    
    * javascript 코드에서 console.log(변수)는, 콘솔 창에 괄호 안의 값을 출력시킵니다.
    이렇게하면 개발자가 결과값을 편하게 볼 수 있습니다.
    
    </aside>
    
- **********************************javascript 문법**********************************
    - 꿀팁
        
        <aside>
        👉 //여러분들이 코딩을 시작하기 전에, 미리 궁금해 하실 것들을 준비해봤습니다!
        
        1. 코드를 마칠 때, 코드 마지막에;를 써도되고 안써도 됩니다!
        let num = 1;
        let num = 1
        2. 변수를 선언할 때 let을 써야 하야 var를 써야 하는가?
        둘 다 무엇을 써도 똑같은 기능을 하지만 우리가 같이 공부할 땐 let을 쓰도록 합시다!
        3. **딕셔너리랑 객체**라는 단어를 혼용해서 쓰던데 뭐가 맞 는것이냐? 둘다 똑같습니다! 우린 딕셔너리 라는
        이름으로 배울 거지만, 혹시 제가 객체라는 말이 툭 튀어 나와도 이해부탁드립니다 (_ _)
        4. 마찬가지로 **리스트와 배열**이라는 어휘도 똑같은 개념이라고 보시면 됩니다!
        5. let first_name = 'bob' // snake case라고 합니다. 
        let firstName = 'bob' // camel case라고 합니다. 
        쉽게 알아볼 수 있게 쓰는 게 중요합니다.회사마다 규칙이 있죠.
        6. 다른 특수문자 또는 띄워쓰기는 불가능합니다!
        </aside>
        
    
    ### 1. 변수 & 기본연산
    
    <aside>
    👉 변수설정시 let 으로
    (ex. let a=open, let b=24)
    
    * 다만 변수이름은 특수문자 or 띄워쓰기는 불가
    
    * 숫자 문자열 별다른 제한이 없다. 
    * 다만 연산시 숫자끼리 하면 계산을 하고 문자끼리면 붙이며 
    
    문자+숫자를 하면 숫자를 문자로 바꾼뒤 그저 이어붙여줍니다
    (ex. a+b=open24)
    
    </aside>
    
    <aside>
    👉 변경 되기 싫은 변수가 있으면 const 로
    (ex. const A = 15 한 이후에 A=13 이런 식으로 바꾸면 에러남 
    TypeError : Assignment to constant variable at ~~~)
    
    </aside>
    
    <aside>
    📌 let message = ` `
    이렇게 백틱을 쓰면 자동으로 줄바꿈도 해주고 ${ } 이렇게 변수를 마음대로 쳐넣을 수도 있다. 
    
    ex. 
    id = "HI"; url = ` [www.naver.com/](http://www.naver.com/) ${id} `;이렇게 하면 되는데 
    이거 안쓰면 url + id; 이렇게 +써야댐
    
    </aside>
    
    - **힙과 스택**
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2017.png)
        
        ### **코드(code) 영역**
        
        메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.
        
        CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
        
        ### **데이터(data) 영역**
        
        메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.
        
        데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.
        
        ### **스택(stack) 영역**
        
        메모리의 스택(stack) 영역은 함수의 호출과 관계되는 **지역 변수와 매개변수**가 저장되는 영역입니다.
        
        스택 영역은 함수의 **호출과 함께 할당되며, 함수의 호출이 완료되면 소멸**합니다.
        
        이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.
        
        스택 영역은 **푸시(push) 동작으로 데이터를 저장**하고, **팝(pop) 동작으로 데이터를 인출**합니다.
        
        이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.
        
        스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.
        
        ### **힙(heap) 영역**
        
        메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역입니다.
        
        힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.
        
        힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.
        
        ## **스택과 힙의 장단점**
        
        ### **스택**
        
        매우 빠른 액세스
        
        변수를 명시 적으로 할당 해제 할 필요가 없습니다.
        
        공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다.
        
        **지역 변수** 만
        
        스택 크기 제한 (OS에 따라 다름)
        
        변수의 크기를 조정할 수 없습니다.
        
        ### **힙**
        
        변수는 전역 적으로 액세스 할 수 있습니다.
        
        메모리 크기 제한 없음
        
        (상대적으로) 느린 액세스
        
        효율적인 공간 사용을 보장하지 못하면 메모리 블록이 할당 된 후 시간이 지남에 따라 메모리가 조각화되어 해제 될 수 있습니다.
        
        메모리를 관리해야합니다 (변수를 할당하고 해제하는 책임이 있습니다)
        
        변수는 C언어 realloc() or 자바 new
        
        힙 스택 알고리즘 참고 
        
        [https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jh20s&logNo=221248339618](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jh20s&logNo=221248339618)
        
    - **기본형과 참조형**
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2018.png)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2019.png)
        
        ---
        
        기본형 타입에 대한 특징으로는 다음과 같다.
        
        - 모두 **소문자**로 시작된다
        - **비객체 타입**이므로 null 값을 가질 수 없다. (기본값이 정해져 있음)
        - **변수의 선언과 동시에 메모리 생성**
        - 모든 값 타입은 메모리의 **스택(stack)에** 저장됨
        - 저장공간에 **실제 자료 값**을 가진다
        
        |  | 타입 | 할당되는 메모리 크기 | 기본값 | 데이터의 표현 범위 |
        | --- | --- | --- | --- | --- |
        | 논리형 | boolean | 1 byte | false | true, false |
        | 정수형 | byte | 1 byte | 0 | -128 ~ 127 |
        | short | 2 byte | 0 | -32,768 ~ 32,767 |  |
        | int(기본) | 4 byte | 0 | -2,147,483,648 ~ 2,147,483,647 |  |
        | long | 8 byte | 0L | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |  |
        | 실수형 | float | 4 byte | 0.0F | (3.4 X 10-38) ~ (3.4 X 1038) 의 근사값 |
        | double(기본) | 8 byte | 0.0 | (1.7 X 10-308) ~ (1.7 X 10308) 의 근사값 |  |
        | 문자형 | char | 2 byte (유니코드) | '\u0000' | 0 ~ 65,535 |
        |  |  |  |  |  |
        
        JAVA
        
        ```
        int age = 25;double price = 100.5;char score = 'A';
        ```
        
        ---
        
        참조형 타입 특징으로는 다음과 같다.
        
        - 기본형 과는 달리 실제 값이 저장되지 않고, 자료가 저장된 공간의 주소를 저장한다.
        - 즉, **실제 값은 다른 곳(힙)**에 있으며 값이 있는 주소를 가지고 있어서 나중에 그 주소를 참조해서 값을 가져온다.
        - 메모리의 힙(heap)에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장
        - 참조형 변수는 null로 초기화 시킬 수 있다
        
        ![https://blog.kakaocdn.net/dn/b3Fd8e/btrJren0bQN/GUGyWN7r7I47VK9rj0lVgk/img.jpg](https://blog.kakaocdn.net/dn/b3Fd8e/btrJren0bQN/GUGyWN7r7I47VK9rj0lVgk/img.jpg)
        
        | 타입 | 기본값 | 할당되는 메모리 크기 |
        | --- | --- | --- |
        | 배열(Array) | Null | 4 byte(객체의 주소값을 저장하니까) |
        | 열거(Enumeration) | Null |  |
        | 클래스(Class) | Null |  |
        | 인터페이스(Interface) | Null |  |
        
        JAVA
        
        ```
        String name = "홍길동";String[] hobby = new String() {"독서", "게임", "등산"};Date date = new Date();
        ```
        
    - **Spread 와 rest 문법 (객체, 배열, 함수에서)**
        
        ---
        
        Rest 파라미터(Rest Parameter, 나머지 매개변수)는 매개변수 이름 앞에 세개의 점 `...`을 붙여서 정의한 매개변수를 의미
        
        Spread 문법(Spread Syntax, `...`)는 대상을 개별 요소로 분리
        
        ---
        
        **Spread**
        
        ```jsx
        const slime = {
          name: '슬라임'
        };
        
        const cuteSlime = {
          ...slime,
          attribute: 'cute'
        };
        ```
        
        여기서 … 이 spread 연산자임. 기존에 사용한 **객체**의 속성들을 그대로 가져오면서 새로운 객체를 만들어줌
        
        ```jsx
        const numbers = [1, 2, 3, 4, 5];
        
        const spreadNumbers = [...numbers, 1000, ...numbers];
        console.log(spreadNumbers); // [1, 2, 3, 4, 5, 1000, 1, 2, 3, 4, 5]
        ```
        
        이렇게 **배열**에서도 spread 연산자를 쓸 수도 있다. (여러번 쓸 수도 있다)
        
        ```jsx
        function sum(...rest) {
          return rest.reduce((acc, current) => acc + current, 0);
        }
        
        const numbers = [1, 2, 3, 4, 5, 6];
        const result = sum(
          numbers[0],
          numbers[1],
          numbers[2],
          numbers[3],
          numbers[4],
          numbers[5]
        );
        console.log(result);
        
        ```
        
        굉장히 불편하죠? 만약에 sum함수를 사용 할 때 인자 부분에서 spread 를 사용하면 다음과 같이 표현이 가능합니다.
        
        ```jsx
        function sum(...rest) {
          return rest.reduce((acc, current) => acc + current, 0);
        }
        
        const numbers = [1, 2, 3, 4, 5, 6];
        const result = sum(...numbers);
        console.log(result);
        
        ```
        
        어떤가요? 정말 편하죠?
        
        ---
        
        **Rest (특정 원소부터 제거하고 새로운 배열을 만드는듯)**
        
        ```jsx
        const purpleCuteSlime = {
          name: '슬라임',
          attribute: 'cute',
          color: 'purple'
        };
        
        const { color, ...rest } = purpleCuteSlime;
        console.log(color);
        console.log(rest);
        //rest 대신 아무거나써도됨
        
        ```
        
        ![https://i.imgur.com/XYg74q3.png](https://i.imgur.com/XYg74q3.png)
        
        **객체**에서는 이렇게 함
        
        ```jsx
        const numbers = [0, 1, 2, 3, 4, 5, 6];
        
        const [one, ...rest] = numbers;
        
        console.log(one);
        console.log(rest);
        
        ```
        
        ![https://i.imgur.com/tEpTlMQ.png](https://i.imgur.com/tEpTlMQ.png)
        
        **배열**에서이렇게함
        
        (비구조화 할당을 통하여 원하는 값을 밖으로 꺼내고, 나머지 값을 rest 안에 넣었습니다)
        
        🌈one은 직관적인데 …rest 에서 rest 를 찍으면 아예 배열이 나오네
        
        ```jsx
        const numbers = [0, 1, 2, 3, 4, 5, 6];
        
        const [..rest, last] = numbers;
        
        ```
        
        ![https://i.imgur.com/E9dyzir.png](https://i.imgur.com/E9dyzir.png)
        
        반면 이렇게 할 수는 없답니다.
        
        ---
        
        ```jsx
        function sum(a, b, c, d, e, f, g) {
          let sum = 0;
          if (a) sum += a;
          if (b) sum += b;
          if (c) sum += c;
          if (d) sum += d;
          if (e) sum += e;
          if (f) sum += f;
          if (g) sum += g;
          return sum;
        }
        
        const result = sum(1, 2, 3, 4, 5, 6);
        console.log(result);
        
        ```
        
        위에서의 sum **함수**는 7개의 파라미터를 받아오는데, 아래에서 사용 할때에는 6개만 넣어줬습니다. 그러면, g 값이 undefined 가 되기 때문에 sum 에 더하는 과정에서 += undefined 를 하게 되면 결과는 NaN
        
        함수의 파라미터가 몇개가 될 지 모르는 상황에서 rest 파라미터를 사용하면 매우 유용합니다. 코드를 다음과 같이 수정해보세요.
        
        ```jsx
        function sum(...rest) {
          return rest.reduce((acc, current) => acc + current, 0);
        }
        
        const result = sum(1, 2, 3, 4, 5, 6);
        console.log(result);
        
        ```
        
        ![https://i.imgur.com/Pvm0tha.png](https://i.imgur.com/Pvm0tha.png)
        
        reduce???
        
    
    ### 2. 리스트 & 딕셔너리
    
    - **리스트나 딕셔너리를 이용하면 ?**
        
        보기도 깔끔해지고, 다루기도 쉬워지고 
        고객이 새로 한 명 오더라도 .push 함수를 이용해 간단하게 대응할 수 있습니다!
        
    
    <aside>
    👉 **리스트 (계란 바구니 aka 배열)**
    
    ⏩ 순서를 지켜서 가지고 있는 형태 [ ] 
    
    리스트 선언시 a=[1,2,’hey’,3] 이런식으로
    
    리스트 출력시 a[1] 이런식으로
    (2가 출력됨)
    
    리스트 요소 넣을시 a.push(’헤이’) 이런식으로
    (a=[1, 2, ”hey”, 3, ”헤이”] 배열이 생김)
    
    리스트 길이 구할시 a.length 
    (5가 출력됨)
    
    </aside>
    
    <aside>
    👉 **딕셔너리 (전화 번호부 aka 객체)**
    
    ⏩ 키와 벨류들의 묶음 { } 
    
    딕셔너리 선언시 a={ ‘name’ : ‘bob’ , ‘age’ : 21} 이런식으로
    
    딕셔너리 출력시 a [’name’] 이런식으로 할 수도 있고 [a.name](http://a.name) 도 가능 
    (bob이 출력됨)
    
    딕셔너리 요소 넣을시 a[’height’]=180 이런식으로
    { name : ‘bob’ , age : 21 , height: 180 }을 출력 ********************************************************************************************
    
    </aside>
    
    <aside>
    📌 **딕셔너리** ****************************************************************비구조할당방식!****************************************************************
    
    blog = { owner : “noah”, getPost() { } }; 이런식으로 딕셔너리를 만든 후 
    blog.getPost( ) 이렇게 꺼낼수도 있음 
    
    let owner = blog.owner 
    let getPost = blog.getPost() 
    이 때, 이렇게 기존 할당 방식으로 선언할 수도 있지만
    
    let { owner, getPost } = blog; 
    이렇게  비구조할당 방식으로 코드를 간결화 할 수 있음 
    (다만 키 값의 이름과 같을 때만 들어감 주의)
    
    ******원래는 그러니까  딕셔너리안에 있는애들을 변수할당시켜주려면 하나하나 다 대응시켜줘야 되는데 싹다 모음. 
    
    게다가 let owner = blog.owner 라고 owner 두 번 쓰지않고, let { owner } = blog; 한번만씀으로서 키값과 동일하게 변수를 설정해주어서 코드 절약.******
    
    </aside>
    
    <aside>
    📌 let name = “안녕”, job=”no”;
    let dict = { name: name, job: job } 
    
    과거에는 이렇게 썼는데 이제는 간단히 가능.
    
    let dict = { name, job}
    
    </aside>
    
    <aside>
    👉 **리스트&딕셔너리 조합**
    
    선언시 names = [ { ‘name‘ : ‘bob’ , ‘age’ : 21 , ‘height’ : 180 }, { ‘name’ : ‘tulip’ } ] 이런식으로 
    
    출력시 names[0][’name’] 이런식으로 
    (bob이 출력됨)
    
    요소 넣을시 new = { ‘name’ : ‘jangmi’ } 후 names.push(new) 이런식으로
    (이때 names[2][’name’] 하면 jangmi 출력됨]
    
    </aside>
    
    ### 3. 함수
    
    <aside>
    👉 Bonus 문자열 나누기
    
    let myemail=’sparta@gmail.com’ 에서 gmail 만 뽑고 싶다면?
    
    result=myemail.split(’@’) 하면 result 에는 리스트 형태로 [’sparta’, ‘gmail.com’] 저장
    
    </aside>
    
    <aside>
    👉 Bonus 문자열 합치기
    
    위의 예제에서 다시 result.join(’>’) 하면 sparta>gamil.com 으로 합쳐짐
    
    </aside>
    
    <aside>
    👉 let a =’sparta’
    후 a.toUpperCase() 하면 싹 대문자로바꿔줌
    
    </aside>
    
    <aside>
    👉 ‘*’.repeat() 하면 ()안에 있는 숫자만큼 ‘*’를 반복함
    
    </aside>
    
    <aside>
    👉 alert(’ ‘); 하면 창 띄움
    
    </aside>
    
    <aside>
    👉 loaction.href=''; 페이지 이동하는애들
    location.replace (''); 페이지 교체하는 애들
    
    원칙적으로 href 를 사용한다. 뒤로가기가 가능하므로.
    그러나 쇼핑몰 결제 등등 뒤로가기가 안되게 하려면 replace.
    
    window 객체는 **웹 브라우저의 창(window)을 나타내는 객체**
    로, 대부분의 웹 브라우저에서 지원하고 있습니다. 자바스크립트의 모든 객체, 전역 함수, 전역 변수들은 자동으로 window 객체의 프로퍼티가 됩니다.
    
    곧 <window.location.href=’’> 이것도 가능
    
    ⚡다만  flask 패키지 쓸 때는
    
    <a href="./login.html">이동</a>얘가 아닌
    <a href="{{url_for('login')}}">이동</a> 넣어줘야됨.
    
    url_for 함수가 파이썬 flask 내에 있는 기능임
    
    곧 javascript 에서는 
    `<button type="button" onclick="***location***.href='{{url_for('login')}}';" class="btn">`
    (a href는 html 태그니깐)
    
    +
    
    추가적으로 서버에 달아줘야함
    
    @app.route('/Log_in.html')
    def Login():
    return render_template('log_in.html')
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2020.png)
    
    </aside>
    
    - **join ( )**
        
        <aside>
        👉 join()
        
        - 배열에 저장된 **모든 원소**를 문자열로 변환 후 연결하여 출력
        - 구분자 지정 가능
        
        ```jsx
        <script>
          let city = ["서울", "부산", "인천"];
        	let joindata1 = city.join(,);
        	let joindata2 = city.join('-');
        	let joindata3 = city.join(' 그리고 ');
        	document.write("조인 결과1: " + joindata1 + "<p/>");
            document.write("조인 결과2: " + joindata2 + "<p/>");
            document.write("조인 결과3: " + joindata3 + "<p/>");
        // '-', '그리고' = 구분자
        </script>
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2021.png)
        
        </aside>
        
    - **함수 축약!**
        
        <aside>
        💰 비구조할당(destructuring assignment)
        : 배열이나 객체의 속성 혹은 값을 해체하여 그 값을 변수에 각각 담아 사용하는 자바스크립트 표현식
        
        ---
        
        **기존 방식**
        blogFunction(blog)
        
        *//배열선언*
        
        const animalList = ['CAT', 'DOG', 'TIGER'];
        
        *//각각 변수담기*
        
        const cat = animalList[0];
        const dog = animalList[1];
        const tiger = animalList[2];
        
        *//각각호출*
        
        console.log(cat);
        console.log(dog);
        console.log(tiger);
        
        **비구조할당 방식**
        
        *//비구조할당방식을 이용하면 4줄을 1줄 코드로 변경 가능*
        
        const [cat1, dog1, tiger1] = ['CAT', 'DOG', 'TIGER'];
        console.log(cat1);
        console.log(dog1);
        console.log(tiger1);
        
        or
        
        const animal = ['CAT', 'DOG', 'TIGER'];
        const [cat1, dog1, tiger1] = animal;
        console.log(cat1);
        console.log(dog1);
        console.log(tiger1)
        
        ---
        
        let blog = {
        	owner : "noah",
        	url : "noahlogs.tistory.com",
        	getPost() { 
        		console.log("ES6 문법 정리"); 
        	}
        };
        
        *** 리액트 네이티브 앱을 만들며 가장 많이 사용할 방식 ***
        let blogFunction = ( {owner, url, getPost} ) ⇒  {
        console.log(owner)
        console.log(url)
        console.log(getPost())
        }
        
        </aside>
        
        <aside>
        ✍️ 구조분해할당
        const Season = {
        	SPRING: "spring",
        	SUMMER: "summer",
        	AUTUMN: "autumn",
        	WINTER: "winter",
        };
        
        Object. freeze(season) 
        // key, value 값을 가진 데이터값은 변경될수있다
        // 가령 Season['NEW']='new' 이런식으로
        // 그래서 얼려준다. 한 번 선언된 객체의 값을 변경하지 못하게 한다.
        
        if(true){ 
        	console.log(Season.SPRING);
        }
        // 객체.프로퍼티 이런 형태로 선언한 값들을 참조할 수도 있지만
        
        if(true){
        	const {SPRING} = Season;
        	console.log(SPRING);
        }
        // 이런형태로 참조도 가능 이걸 '구조분해할당' 이라고함. 
        // 여러번 혹은 다른 상수 WINTER 등도 사용해야한다면 이렇게 하기
        
        </aside>
        
    - **map 함수!**
        
        <aside>
        👉 **map 함수!
        
        map( ) 함수**는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 **새로운 배열을 반환**합니다.
        
        ⇒ 결국 기존 배열을 새로운 배열로 매핑한다는 뜻인듯?
        
          `arr.map(callback(currentValue[, index[, array]])[, thisArg])`
        
        📌 긍께 map 안에 함수를 만드는겨.
        
        f (x) 하면 배열 값 (currentvalue) 들이 쭉쭉쭉 나와 새로운 배열되고
        f (x, y) 하고 y 치면 배열 번호(index) 들이 쭉쭉쭉 나와 새로운 배열 만들고
        f (x, y, z) 하고 z 치면 .. 일단은 전체 배열이 배열의 한원소로 다들감
        (그니까 [ [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5]….] 이렇게 )
        
        **map( ) 함수**는 **값과 인덱스를 인자로 받아 자동으로 for문을 돌려 값을 빼도록 해준다.**
        
        map( ) 함수의 **값 인자는 향상된 for문의 item 인자와 같은 역할**,
        
        map( ) 함수의 **인덱스 인자는 기본 for문 방식의 index 와 같은 역할!!**
        
        **예시)**
        
        ```jsx
        let numbers = [1,2,3,4,5,6,7];
        for(let i=0; i<numbers.length; i++){
        	console.log(numbers[i]);
        }
        
        기존에는 이렇게 반복문을 씀. 
        
        let numbers = [1,2,3,4,5,6,7];
        numbers.map(
        	function(value,i){ 
        		console.log(value,i) 
        	}
        )
        
        반면 map 함수는 리스트 길이값 몰라도 지가 알아서 반복문 돕니다
        ****몇 번째 순서인지도 알려주면서.
        
        결과
        //1 0
        //2 1
        //3 2
        //4 3
        //5 4
        //6 5
        //7 6
        
        +
        이렇게 조질수도 있음
        
        numbers**.map**(
        	(value,i) **=>** {
        		console.log(value,i) 
        	}
        )
        ```
        
        ---
        
        +응용1
        
        ![Map 함수 쓰기전](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2022.png)
        
        Map 함수 쓰기전
        
        ![Map 함수 쓴이후
        ](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2023.png)
        
        Map 함수 쓴이후
        
        ---
        
        +응용2 (특정과일개수 세기)
        
        ```jsx
        let fruit_list = ['사과','감','감','배','포도','포도','딸기','포도','감','수박','딸기']
        count=0;
        
        fruit_list.map(
        	function (value,i) { 
        		if(value == '딸기') 
        			count += 1 
        		}
        )
        console.log(count)
        
        요렇게 조지면 딱 2 뜸
        ```
        
        ✅정답
        
        ```jsx
        let count = 0;
        
        fruit_list.map(
        	(f)=> { 
        		if(f == "딸기")
        			count += 1 
        		}
        )
        
        console.log(count)
        ```
        
        괄호 안써줘도 되는데…?
        
        📌 긍께 사실은 저 f 가 f(x) 에서 x 를 의미하는거여.
        map 함수는 f(x,y,z) 이렇게 받는건데 이걸 (x,y,z) ⇒ 이렇게 표현할 수도 있지
        f(x) 이걸 (x) ⇒ 이렇게 표현 할 수도 있는데 변수하나면 괄호 생략할수있는듯
        
        </aside>
        
    - **filter 함수! (map함수 공부하고 오기)**
        
        <aside>
        👉 filter 함수!
        
        filter( ) 함수는 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다.
        
        ⇒ 매핑과 다르게 통과하는 애들만 딱 배열로 만들어준다 이말인듯
        
        filter 함수는 true 가 들어올 때만 그 리스트(배열)의 요소를 쓰고 false 인 경우는 그 요소를 삭제한 후 최종적으로 남는 배열을 띄우는 함수라고 생각하면될까요?
        
        `arr.filter(callback(element[, index[, array]])[, thisArg])`
        
        **예시)**
        
        ```jsx
        const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
        
        const result = words.filter(word => word.length > 6);
        
        console.log(result);
        // expected output: Array ["exuberant", "destruction", "present"]
        ```
        
        이렇게 딱 변수 조건 걸어주면 그에 맞는거는 뱉고 안맞는건 씹는다~ 이말이야
        
        ---
        
        +응용 1
        
        ```jsx
        let fruit_list = ['사과','감','감','배','포도','포도','딸기',
        '포도','감','수박','딸기']
        
        let SIBAL = fruit_list.filter(
        f => f.startsWith('포도')
        )
        
        console.log(SIBAL) 
        ```
        
        요렇게 조지면 딱 [’포도’, ‘포도’, ‘포도’] 만들어짐
        
        ✅정답
        
        ```jsx
        let podo_list = fruit_list.filter(
        	(f)=> { return f == '포도'}
        )
        
        console.log(podo_list) //['포도','포도','포도']
        
        답지에서는 이렇게 조짐
        ```
        
        </aside>
        
    - **onClick 함수**
        
        ```jsx
        <button onClick={function() {handleClearClick()}}>처음으로</button>
        ```
        
        button 내에 onClick 으로 함수동작시키고 싶으면 
        
        단순히 { handleClearClick( ) } 넣는게 아니라 일케해야함
        
        { **function( ) { handleClearClick( ) }** }혹은 { **( ) ⇒ handleClearClick( )** }
        
        ```jsx
        <HandButton value={0} onClick={function() {setHand('0'); generateRandomHand(); handleRollClick(); moneyUp();}}/>
        
        function HandButton({value,onClick}) {
            const pae=['rock','scissor','paper']
        
            const handleClick = () => {
                onClick();
        //여기 onClick은 컴포넌트가 받은 prop 일거고
                //alert(pae[value]);
            }
            //const handleClick = () => onClick(value);
        
            return (
            <>
            <button onClick={() => handleClick()}> 
        //여기 onClick은 버튼 속성
                <HandIcon text="주사위" value={value}/> 
            </button>
            </>
            )
        }
        
        export default HandButton;
        ```
        
        컴포넌트안에 onClick 넣고 싶으면 이렇게 내부에 onClick 따로 만들어서 버튼을 눌렀을 때(버튼의 onClick) 속성으로 받은 onClick이 뜨게해야함
        
    - **onChange 함수**
        
        ```jsx
        const inputis = (x) => {
            const gabs = Number(x.target.value);
        //Number 함수 사용함으로써 gabs 이 문자열이 아닌 숫자가 되고 더하기 연산자를 했을때 뒤에 이어붙이는게 아니라 실제로 더해줌.
        
            setGabs(gabs);
          };
        
        function App() {
        ...
        
          return (
            <div className="App">
                <h1 id="title"> 가위바위보 해드립니다 ㅎㅎ </h1>
                <img src={logo} className="App-logo" alt="logo" />
                <br></br>
                <input type="number" onChange={inputis}></input> 
        // type="number"하니 숫자만 입력되네
                <br></br>
                <b>판 돈: {gabs}원</b>
            </div>
          );
        
        }
        ```
        
        onChange 는 입력이 변화되었을 때 동작한다고함. 
        
        input 태그안에 onChange 를 넣고 inputis 라는 함수를 실행하게 되는데,
        
        이는 입력이벤트가 발생하면 그에 대한 값을 숫자형으로 바꿔 gabs에 저장하고 있음.
        
- 🌟 **JQuery // 라이브러리임**
    
    <aside>
    👉 JQuery란?
    Javascript 를 미리 작성해둔 것.
    라이브러리임. 
    
    Javascript 보다 직관적이고 간단하게 쓸 수 있다.
    또 예전엔 브라우저마다 자바스크립트 코드가 달랐어서 JQuery가 핫했음
    
    </aside>
    
    <aside>
    👉 JQuery 사용법
    
    head 안에 다음 코드 써주면됨
    `<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js">
    </script>`
    
    CSS에서 <div class=” ”> 로 소환했듯이, <div id=” “> 로 소환시키면됨
    
    </aside>
    
    <aside>
    👉 JQuery 예제
    
    $ → JQuery를 먹이겠다
    ’#url’ →id가 url 인 애에다가
    .val → val 을 넣고싶어
    
    $('#url').val('값')
    넣으면 url에 값 입력됨
    
    $('#url').val() 
    하면 되려 가져옴 
    
    $('#post-box').hide()
    id가 post-box 인 애들을 숨김
    
    $('#post-box').show()
    다시 보여줌
    ex. css 에서 display : none; 해놓으면 처음에 감춰놓았다가 나중에 함수호출시 박스 띄워줌!
    
    ★
    let temp_html=`<button>버튼임</button>` 
    문자열을 정의함(기호주의. ‘ 아니고 ` 임)
    
    ★
    $('#card-box').append(temp_html)
    이러면 id=”card-box” 인 태그안에 html 화해서 버튼이 들어감
    (계속넣으면 계속 들어감. 꼭 한개클래스 아니다)
    
    ★📌
    (참고로 제목 붙일 때, let mytitle=’타이타닉’ 이렇게 정의해놓고 html 화 할 문자열에 대신 ${mytitle} 쓰면 그게 쏙 들어감)
    
    ⚡안쓰고 gu_mise 가면 안된다 주의
    
    ```
    <script>
    let gu_mise = rows[i]['IDEX_MVL'] // 어떤 데이터값
    
    let temp_html = `<Li>**${gu_mise}**</Li>
    
    $'(#names_q1').append(temp_html)
    </script>
    
    <body>
    <ul id="names-q1"></ul>
    </body>
    
    이러면 딱 gu_mise 값이 ul안에 리스트로 들어가지용~~
    ```
    
    $('#card-box').empty() 하면 지움
    
    $('#card-box').empty() 하면 제일 첫 위치에 요소 추가된다고함
    
    $('#card-box').remove() 하면 그에 해당하는 요소 자체를 삭제
    
    ```html
    <p id="one">안녕하세요.</p>
    <p id="two">devkuma입니다.</p>
    <p id="three">반갑습니다.</p>
    `
    
    요소 중에 id가 one, two인 요소를 삭제한다.
    
    $("p").remove("#one, #two");
    
    이렇게 특정 태그 p만 삭제가능하며, 
    p중 특정한 무엇만삭제도 가능
    ```
    
    $(’#card-box’).attr(”name”) 하면 id=”card-box” 속성의 name 을 가져옴
    
    $(’#card-box’).attr(”name”, “attrName”) 하면 id=”card-box” 속성의 attrName으로 변경 
    
    $(’#card-box’).text() 하면 해당 속성을  가져옴
    
    $(’#card-box’).text(”블라블라”) 하면 이전내용 지우고 새로운 내용을 넣음. 
    
    ```html
    $('#img-rtan').attr('src',url); // "src" 해도 되는데?
    $('#text-rtan').text(`${msg} 한마디로 병신이죠!`); // 그냥 msg 해도 되는데?
    
    <div>
     <img id="img-rtan" width="300" src="http://spartacodingclub.shop/static/images/rtans/SpartaIcon11.png"/>
     <h1 id="text-rtan">나는 ㅇㅇㅇ하는 르탄이!</h1>
    </div>
    ```
    
    <aside>
    👉 **로딩**
    
    로딩되면 ajax 통해 temp 불러와서 body temp 인곳에 text 치환해주는 것임
    
    굵은 글씨가  로딩함수 {  } 여기안에 로딩되면 할 거 씀 
    
    ```html
    **$(document).ready(function ()** {
                alert('다 로딩됐다!')
                //로딩이완료된다=값을 머 가져온다 이런뜻인듯
    
                $.ajax({
                  type: "GET",
                  url: "http://spartacodingclub.shop/sparta_api/weather/seoul",
                  data: {},
                  success: function (response) {
                      $('#temp').text(response['temp'])
                  }
                })
            });
    ```
    
    **새로고침**
    완료되면 새로고침 한번해주는 함수
    
    ```python
    $.ajax({
                    type: 'POST',
                    url: '/mars',
                    data: { name_give:name, address_give:address, size_give:size },
                    success: function (response) {
                        alert(response['msg'])
                        **window.location.reload()**
                    }
                });
    ```
    
    </aside>
    
    </aside>
    
- 🌟 **JQuery-AJAX**
    
    ### API
    
    API는 은행 창구와도 같다.
    다양한 API가지고 서버에 콜을 보내서 받아와서 웹사이트에 활용?
    
    GET → 데이터 Read 시 (ex. [naver.com/movie/bimi/](http://naver.com/movie/bimi/) 여런게 이런 코드를 들고 갔다!)
    
    POST → 데이터 Create, Update, Delete 요청 할 때
    
    - **AJAX란?**
        
        <aside>
        👉 *AJAX → Asynchronous JavaScript and XML. 빠르게 동작하는 동적인 웹 만들기 위한 개발 기법
        
        Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있습니다?
        
        Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시할 수 있습니?
        
        이때 서버와는 다음과 같은 다양한 형태의 데이터를 주고받을 수 있습니다.
        
        - JSON →  딕셔너리와 리스트가 합쳐서 내려오는것
        - XML
        - HTML
        - 텍스트 파일 등
        </aside>
        
        <aside>
        👉 **Ajax의 장점**
        
        1. 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있습니다.
        2. 웹 페이지가 로드된 후에 서버로 데이터 요청을 보낼 수 있습니다.
        3. 웹 페이지가 로드된 후에 서버로부터 데이터를 받을 수 있습니다.
        4. 백그라운드 영역에서 서버로 데이터를 보낼 수 있습니다.
        </aside>
        
        <aside>
        👉 **Ajax의 한계**
        
        1. Ajax는 클라이언트가 서버에 데이터를 요청하는 클라이언트 풀링 방식을 사용하므로, 서버 푸시 방식의 실시간 서비스는 만들 수 없습니다.
        2. Ajax로는 바이너리 데이터를 보내거나 받을 수 없습니다.
        3. Ajax 스크립트가 포함된 서버가 아닌 다른 서버로 Ajax 요청을 보낼 수는 없습니다.
        4. 클라이언트의 PC로 Ajax 요청을 보낼 수는 없습니다.
        </aside>
        
    - ****************************AJAX 사용법****************************
        
        <aside>
        👉 **AJAX 기본 골격**
        
        ```html
        $.ajax({
        	type: "GET",
        	url: "여기에URL을입력",
        	data: {},
        	success: function(response){
        		console.log(response)
        		}
        })
        ```
        
        console.log 넣으면 콘솔창에 보임
        
        ```html
        	success: function (response) {
        	
        	            let url = response['url']
        	            let msg = response['msg']
        	            console.log(url,msg)
        	          }
        ```
        
        이렇게 url, msg 둘다 입력해서 띄우기도 가능
        
        </aside>
        
        <aside>
        👉 **GET vs POST (둘다 브라우저가 서버에 요청하는 것)**
        
        ---
        
        GET 방식은 주소에 데이터(data)를 추가하여 전달하는 방식
        
        GET 요청은, url뒤에 아래와 같이 붙여서 데이터를 가져갑니다.
        http://naver.com?param=value&param2=value2 
        
        ---
        
        ✍️ About GET
        
        - GET 요청은 캐시가 가능하다.
        - : GET을 통해 서버에 리소스를 요청할 때 웹 캐시가 요청을 가로채 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. HTTP 헤더에서 cache-control 헤더를 통해 캐시 옵션을 지정할 수 있다.
        - GET 요청은 브라우저 히스토리에 남는다.
        - GET 요청은 길이 제한이 있다.
        - GET 요청은 중요한 정보를 다루면 안된다. (보안)
        
        ---
        
        POST 방식은 데이터(data)를 별도로 첨부하여 전달하는 방식
        
        POST 요청은, data : {} 에 넣어서 데이터를 가져갑니다.
        data: { param: 'value', param2: 'value2' },
        
        ---
        
        ✍️ About POST
        
        - POST 요청은 캐시되지 않는다.
        - POST 요청은 브라우저 히스토리에 남지 않는다.
        - POST 요청은 데이터 길이에 제한이 없다.
        
        ---
        
        </aside>
        

### Python

---

- **파이썬 문법과 패키지(모듈합쳐진 것)**
    - 파이썬 문법
        
        <aside>
        👉 문법
        
        print('hello sparta!!')
        
        <리스트>
        a_list=['사과','배','감']
        a_list.append('수박') // 파이썬은 이렇게 append 로 추가 
        print(a_list)
        
        <딕셔너리>
        a_dict = {
            'name' : 'bob',
            'age' : 27
        }
        # 이렇게 놓는게 깔끔하쥬?
        
        print(a_dict['name'])
        
        <함수>
        def sum(a,b) :
            print('더하자!')
            return a+b
        
        result = sum(1,2)
        print(result)
        
        def is_audlt(age):
            if age > 20:
                print('성인입니다')
            else:
                print('청소년입니다')
        
        is_audlt(15)
        
        ⚡**return 이 함수의 종료 나타내는듯. return 하고 이후에 뭐 하면 안먹힘**
        
        <리스트 반복문>
        fruits = ['사과','배','배','감','수박','귤','딸기','사과','배','수박']
        
        count = 0
        for aaa in fruits:
            if aaa == '씨팔':
                count += 1
        
        print(count)
        #파이썬은 애당초 반복문을 리스트와 함께쓰게 기획됨. 리스트 요소하나씩 꺼내서 내용물에쓴다
        #for 문은 if~ 1 까지가 내용물
        
        <딕셔너리 반복문>
        people = [{'name': 'bob', 'age': 20},
                  {'name': 'carry', 'age': 38},
                  {'name': 'john', 'age': 7},
                  {'name': 'smith', 'age': 17},
                  {'name': 'ben', 'age': 27}]
        #이건 딕셔너리
        
        for person in people:
            if person['age']>20:
                print(person['name'])
        #딕셔너리도 이렇게. 이게 파이썬이 자바스크립트와 다른부분
        
        </aside>
        
    - 파이썬 내장함수
        - strip
            
            <aside>
            👉 strip()이용하면 문자열 특정문자 제거 가능. (자바…등등 비슷)
            
            - `strip([chars])` : 인자로 전달된 문자를 String의 왼쪽과 오른쪽에서 제거합니다.
            - `lstrip([chars])` : 인자로 전달된 문자를 String의 왼쪽에서 제거합니다.
            - `rstrip([chars])` : 인자로 전달된 문자를 String의 오른쪽에서 제거합니다.
            
            공백제거
                
                ```python
                text = ' Water boils at 100 degrees '
                print('[' + text.rstrip() + ']')
                print('[' + text.lstrip() + ']')
                print('[' + text.strip() + ']')
                ```
                
                ```python
                //결과
                [ Water boils at 100 degrees]
                [Water boils at 100 degrees ]
                [Water boils at 100 degrees]
                ```
                
                응용) 동일한 문자 제거
                `text = '0000000Water boils at 100 degrees 000'`
                `print(text.strip('0'))`
                결과 : `Water boils at 100 degrees`
                
                응용)  여러 문자 제거
                `text = ",,,,,123.....water....pp"`
                `print(text.strip(',123.p'))`
                결과 : `water`
                
                응용)  특정 문자 제거
                `text = ' Water boils at 100 degrees '`
                `print(text.strip(' degrees '))`
                결과 : `Water boils at 100`
                
            </aside>
            
        - repeat
            
            <aside>
            👉 repeat( ) 함수 이용하면 괄호안의 숫자만큼 ‘ ‘ 안에 있는것을 반복시켜준다
            
            `let star_image='🧡'.repeat(star)`
            
            </aside>
            
        - int
            
            <aside>
            👉 문자를 숫자로 바꿔주는 함수
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2024.png)
            
            가령 서버가 html 에서 bucket_give 를 숫자로 줘도 서버는 문자로 인식함
            이를 int 이용해서 숫자로 바꿔줘야 서버에 숫자 1로 들어감
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2025.png)
            
            </aside>
            
        - open ( )
            
            파일을 열 때는 기본적으로 `with` 문을 통해 `open()` 내장 함수를 호출하는 것이 권장됩니다. `with` 문을 사용하지 않을 경우, 파일 닫기를 스스로 해줘야 해서 불필요하게 코드가 지저분해지기 때문.
            
            `open()`  내장 함수는 첫번째 인자로는 파일명, 두번째 인자로는 모드를 받습니다. 파일에 데이터를 쓸 때는 `w`모드를 사용하고 파일을 열고, 파일 핸들러의 `write()`메서드를 사용해서 쓸 데이터를 넘기면 됩니다. 
            
            (단 write 안에는  string 만 가능하니 str( ) 이용해서 type 변경한 후 f.write 가 필요)
            
            ```python
            f=open('hello.txt','w') #write모드
            f.write('Hello Python')
            f.close()
            ```
            
            ```python
            with open('hello.txt','w') as f:
                f.write('hello Python!!')
            ```
            
            1. r (read mode) : 읽기 전용 모드 (기본값)
            2. w (write mode) : 쓰기 전용 모드
            3. a (append mode) : 파일의 마지막에 새로운 데이터를 추가하는 모드
            
            ```python
            # kakao_code.json에 파일 저장
            with open("kakao_code.json", "w") as fp:
                json.dump(tokens, fp)
            
            # kakao_code.json 읽어들임
            with open("kakao_code.json", "r") as fp:
                tokens = json.load(fp)    
                access_token=tokens["access_token"]
            print(tokens["access_token"])
            ```
            
    - 패키지란? (venv와 pip?)
        
        <aside>
        👉 패키지란?
        
        Python 에서 패키지는 모듈(일종의 기능들 묶음)을 모아 놓은 단위 
        
        이런 패키지 의 묶음을 라이브러리 라고 볼 수 있다. 
        
        (지금 여기서는 외부 라이브러리를 사용하기 위해서 패키지를 설치함)
        
        파이썬 파일 →설정→ 인터프리터 → +눌러서 설치가능
        
        </aside>
        
        <aside>
        👉 가상환경(virtual environment)이란?
        
        회사에서 패키지 ABC 쓰고 나는 BCDE 쓰고 있었는데
        회사에서 B대신 B’ 를 쓰자고 하면?
        내가 개인적으로 쓰던 B 다빠꿔야됨?
        
        이럴 때 가상환경을 만들어 라이브러리를 다 모아놓는다
        즉 프로젝트별로 패키지들을 담을 공구함이 virtual environment
        *venv 가 Virtual ENVironment
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2026.png)
        
        다시말해 여러개의 파이썬 프로젝트가 있을 때 호환성의 문제가 생길 수 있음.
        
        왜냐하면 파이썬에서는 한 라이브러리에 하나의 패키지 버전만 설치가능하기 때문 
        
        이를 방지하기 위해 각 프로젝트별로 격리된 독립적 가상환경을 생성한다.
        
        *cmd 를 켜고 가상환경 폴더를 만들고 싶은 위치에서
        python -m venv {가상환경 폴더명}
        혹은
        python -m venv {가상환경 폴더생성 경로 + 폴더명}
        
        이렇게 하면 설치 완료
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2027.png)
        
        </aside>
        
        <aside>
        👉 pip (python install package) 이란?
        
        앱을 설치할 때 앱스토어/플레이스토어를 가듯이, 새로운 프로젝트의 라이브러리를 가상환경(공구함)에 설치하려면 pip 을 이용하게 됨
        
        </aside>
        
        <aside>
        👉 폴더 트리
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2028.png)
        
        venv 만든 후 
        새로만들기 → 경로 → templates, static 도 만들어준다
        
        </aside>
        
    - 패키지 사용 예시 (패키지 : requests)
        
        <aside>
        👉 import requests # requests 라이브러리 설치 필요
        
        r = requests.get('http://spartacodingclub.shop/sparta_api/seoulair')
        rjson = r.json()
        #리퀘스트 라이브러리
        
        rows = rjson['RealtimeCityAir']['row']
        
        # print(rows)
        
        for row in rows:
            gu_name = row['MSRSTE_NM']
            gu_mise = row['IDEX_MVL']
            if gu_mise < 60:
                print(gu_name)
        
        </aside>
        
- **파이썬 모듈 (함수들이 .py 안에 뭉쳐진 것)**
    - **JSON**
        
        .json( ) 메소드는 JavaScript 객체리터럴을 JSON 문자열로 변환한다.
        
        *객체 리터럴이란 중괄호({})로 감싸진 하나 이상의 속성 이름과 속성 값의 리스트
        
        ```python
        const num = 1; // num은 상수이고 1은 10진수 정수 리터럴입니다.
        let str = '이름'; // str은 변수이고 '이름'은 문자열 리터럴입니다.
        const array = []; // [] = 배열 리터럴.
        const object = {}; // {} = 객체 리터럴.
        ```
        
        - load ( ) : **JSON 파일**에 저장된 데이터를 읽어서 Python 객체로 불러오고 싶을 때
            
            ```jsx
            {
              "id": 1,
              "username": "Bret",
              "email": "Sincere@april.biz",
              "address": {
                "street": "Kulas Light",
                "suite": "Apt. 556",
                "city": "Gwenborough",
                "zipcode": "92998-3874"
              },
              "admin": false,
              "hobbies": null
            }
            ```
            
            ```jsx
            import json
            
            with open('input.json') as f:
                json_object = json.load(f)
            
            assert json_object['id'] == 1
            assert json_object['email'] == 'Sincere@april.biz'
            assert json_object['address']['zipcode'] == '92998-3874'
            assert json_object['admin'] is False
            assert json_object['hobbies'] is None
            ```
            
        - loads ( ) : JSON 문자열을 Python 객체로 변환하고 싶을 때
            
            ```jsx
            import json
            
            json_string = '''{
                "id": 1,
                "username": "Bret",
                "email": "Sincere@april.biz",
                "address": {
                    "street": "Kulas Light",
                    "suite": "Apt. 556",
                    "city": "Gwenborough",
                    "zipcode": "92998-3874"
                },
                "admin": false,
                "hobbies": null
            }'''
            
            json_object = json.loads(json_string)
            
            assert json_object['id'] == 1
            assert json_object['email'] == 'Sincere@april.biz'
            assert json_object['address']['zipcode'] == '92998-3874'
            assert json_object['admin'] is False
            assert json_object['hobbies'] is None
            ```
            
            파일에 저장되어 있는 JSON 문자열을 읽거나 HTTP 요청의 전문(body)를 읽을 때 자주 사용
            
        - dump ( ) : Python 객체를 **JSON** **파일**에 저장하고 싶을 때
            
            ```python
            import json
            
            json_object = {
                "id": 1,
                "username": "Bret",
                "email": "Sincere@april.biz",
                "address": {
                    "street": "Kulas Light",
                    "suite": "Apt. 556",
                    "city": "Gwenborough",
                    "zipcode": "92998-3874"
                },
                "admin": False,
                "hobbies": None
            }
            
            with open('output.json', 'w') as f:
                json.dump(json_object, f, indent=2)
            ```
            
            ```python
            {
              "id": 1,
              "username": "Bret",
              "email": "Sincere@april.biz",
              "address": {
                "street": "Kulas Light",
                "suite": "Apt. 556",
                "city": "Gwenborough",
                "zipcode": "92998-3874"
              },
              "admin": false,
              "hobbies": null
            }
            ```
            
            JSON 포맷의 HTTP 요청 전문(body) 을 쓸 때 이 방식을 사용
            
        - dumps ( ) : Python 객체를 JSON 문자열로 변환하고 싶을 때
            
            ```python
            import json
            
            json_object = {
                "id": 1,
                "username": "Bret",
                "email": "Sincere@april.biz",
                "address": {
                    "street": "Kulas Light",
                    "suite": "Apt. 556",
                    "city": "Gwenborough",
                    "zipcode": "92998-3874"
                },
                "admin": False,
                "hobbies": None
            }
            
            json_string = json.dumps(json_object)
            print(json_string)
            ```
            
            콘솔결과
            
            `{"id": 1, "username": "Bret", "email": "Sincere@april.biz", "address": {"street": "Kulas Light", "suite": "Apt. 556", "city": "Gwenborough", "zipcode": "92998-3874"}, "admin": false, "hobbies": null}`
            
        
         
        
- 🌟 **크롤링 (패키지 : requests, bs4)**
    - 크롤링이란?
        
        <aside>
        👉 메타 태그
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2029.png)
        
        가령 카톡공유를 하면 이렇게 홈피에서 심어놓은 메타 태그를 보게 됨. 
        
        이처럼 메타 태그는 <head></head> 부분에 들어가는,
        
        눈에 보이는것(body) 외에 사이트 속성을 설명해주는 태그들임
        (구글 검색시 표시될 설명문, 사이트제목, 카톡공유 이미지 등등)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2030.png)
        
        메타 태그를 심어놓을 수도 있고 심어놓은것을 크롤링으로 긁어올 수도 있다?
        
        </aside>
        
        <aside>
        👉 크롤링을 하려면 남들이 만들어 놓은 라이브러리(패키지) 써야댐
        
        </aside>
        
    - 크롤링하는법
        
        <aside>
        👉 BeautifulSoup 기본 세팅
        
        얘도 beautifulsoup 설치필요
        
        ```python
        import requests
        from bs4 import BeautifulSoup
        
        # 타겟 URL을 읽어서 HTML를 받아오고,
        headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'}
        # 헤더는 코드에서 콜을 날리는데 마치 브라우저에서 콜날리는것처럼 하려고 쓴다
        data = requests.get('https://movie.naver.com/movie/sdb/rank/rmovie.naver?sel=pnt&date=20210829',headers=headers)
        
        # HTML을 BeautifulSoup이라는 라이브러리를 활용해 검색하기 용이한 상태로 만듦
        # soup이라는 변수에 "파싱 용이해진 html"이 담긴 상태가 됨
        # 이제 코딩을 통해 필요한 부분을 추출하면 된다.
        soup = BeautifulSoup(data.text, 'html.parser')
        # 여기까지가 기본적인 세팅.
        
        #############################
        # (입맛에 맞게 코딩)
        #############################
        
        print(soup)
        # print(soup)이러면 콘솔창에서 보이는거 다 가져옴
        ```
        
        </aside>
        
        <aside>
        👉 BeautifulSoup 사용법
        
        🌟 **1) 태그 안의 텍스트를 찍고 싶을 땐 → 해당 태그.text
        cf) text[0:2] 하면 앞 두글자만 끊어줌**
        
        🌟 **2) 태그 안의 속성을 찍고 싶을 땐 → 해당 태그[’속성’]** 📌
        
        ⭐ **3) 하위에 태그가 여러게 있으면 [div.name](http://div.name) 이런식으로 구분해서 들어가는듯**
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2031.png)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2032.png)
        
        즉 여기서 
        ⭐ 1)
        a > div > [div.name](http://div.name) >strong 하면 <strong> </strong> 다불러옴
        a > div > [div.name](http://div.name) >strong 한다음 .text 하면 strong 안에 있는거만 씀
        ⭐ 2)
        a > p> img 에서 안에있는 속성만 불러오고싶으면 뒤에 [’src’] 해주기!
        ⭐ 3)
        div.name 이랑 같은 위치에 evt_info, score,price 도 있음. 구분위해 div.name
        
        **🌟request.get 에서 url 수정해줘야됨 조심.**
        
        ```python
        import requests
        from bs4 import BeautifulSoup
        
        url = 'https://movie.naver.com/movie/sdb/rank/rmovie.naver?sel=pnt&date=20210829'
        # URL을 읽어서 HTML를 받아오고,
        
        headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'}
        # 헤더는 코드에서 콜을 날리는데 마치 브라우저에서 콜날리는것처럼 하려고 쓴다
        
        data = requests.get(url, headers=headers)
        # HTML을 BeautifulSoup이라는 라이브러리를 활용해 검색하기 용이한 상태로 만듦
        
        soup = BeautifulSoup(data.text, 'html.parser')
        # soup이라는 변수에 "파싱 용이해진 html"이 담긴 상태가 됨
        
        # 이제 코딩을 통해 필요한 부분을 추출하면 된다.
        
        #걍 구성찍어서 copy selector 하면 이렇게됨
        '#old_content > table > tbody > tr:nth-child(2) > td.title > div > a'
        
        # select를 이용해서, tr들을 불러오기
        movies = soup.select('#old_content > table > tbody > tr')
        
        # movies (tr들) 의 반복문을 돌리기
        for movie in movies:
            # movie 안에 a 가 있으면,
            a_tag = movie.select_one('td.title > div > a')
            if a_tag is not None:
                # a의 text를 찍어본다.
                print (a_tag.text)
        ```
        
        </aside>
        
        <aside>
        👉 *copy selector 사용법
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2033.png)
        
        ```python
        # 선택자를 사용하는 방법 (copy selector)
        soup.select('태그명')
        soup.select('.클래스명')
        soup.select('#아이디명')
        
        soup.select('상위태그명 > 하위태그명 > 하위태그명')
        soup.select('상위태그명.클래스명 > 하위태그명.클래스명')
        
        # 태그와 속성값으로 찾는 방법
        soup.select('태그명[속성="값"]')
        
        # 한 개만 가져오고 싶은 경우
        soup.select_one('위와 동일')
        ```
        
        </aside>
        
        <aside>
        👉 beautifulsoup 이용해서 순위,제목,별점 크롤링
        
        ```python
        import requests
        from bs4 import BeautifulSoup
        
        headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'}
        data = requests.get('https://movie.naver.com/movie/sdb/rank/rmovie.naver?sel=pnt&date=20210829',headers=headers)
        
        soup = BeautifulSoup(data.text, 'html.parser')
        
        #old_content > table > tbody > tr:nth-child(3) > td.title > div > a
        #old_content > table > tbody > tr:nth-child(4) > td.title > div > a
        
        movies = soup.select('#old_content > table > tbody > tr')
        
        for movie in movies:
            a = movie.select_one('td.title > div > a')
            if a is not None:
                title = a.text
                rank = movie.select_one('td:nth-child(1) > img')['alt']
                star = movie.select_one('td.point').text
                print(rank, title, star)
        ```
        
        </aside>
        
    - 크롤링 예제1 - 지니뮤직 (예제코드 有)
        
        <aside>
        👉 예제코드
        
        ```python
        import requests
        from bs4 import BeautifulSoup
        
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'}
        # 헤더는 코드에서 콜을 날리는데 마치 브라우저에서 콜날리는것처럼 하려고 쓴다?
        data = requests.get('https://www.genie.co.kr/chart/top200?ditc=M&rtm=N&ymd=20210701',
                            headers=headers)
        
        soup = BeautifulSoup(data.text, 'html.parser')
        
        #print(soup)
        
        musics = soup.select('#body-content > div.newest-list > div > table > tbody > tr')
        for music in musics:
            순서 = music.select_one('td.number').text[0:2]
            제목 = music.select_one('td.info > a.title.ellipsis').text
            가수 = music.select_one('td.info > a.artist.ellipsis').text
            print(순서.strip(),제목.strip(),가수)
        ```
        
        결과
        
        ![지니 뮤직 사이트](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2034.png)
        
        지니 뮤직 사이트
        
        ![크롤링 해옴](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2035.png)
        
        크롤링 해옴
        
        </aside>
        
    - 크롤링 예제2 - 야놀자(셀레니움?) 미완성
        
        <aside>
        👉
        
        야놀자의 경우 정적페이지가 아닌 동적페이지라서 셀레니움을 사용하여 크롤링 해주셔야한다고 합니다. 아래 링크로 들어가시면 사용방법 나와있으니 해당 페이지 참고하여 진행해주세요~!
        
        [https://beomi.github.io/gb-crawling/posts/2017-02-27-HowToMakeWebCrawler-With-Selenium.html](https://beomi.github.io/gb-crawling/posts/2017-02-27-HowToMakeWebCrawler-With-Selenium.html)
        
        </aside>
        
- 🌟 **데이터베이스 (패키지 : pymongo, dnspython)**
    - 데이터베이스란?
        
        <aside>
        👉 **DB를 왜 쓰는 것일까?**
        
        한마디로 우리가 나중에 잘 찾기 위해서. 
        교보문고에서 일련의 규칙대로 책을 꽂아넣듯 DB에는 Index 라는 순서로 데이터들이 정렬되어 있다.
        
        이 순서대로 우리가 나중에 뽑았을 때 일일이 안찾아도 한번에 뽑히게 하는데 목적이 있다.
        
        </aside>
        
        <aside>
        👉 **DB의 종류
        
        SQL** : 칸을 만들어 놓고 채우는 느낌(엑셀에다 이름, 메일 … 넣듯)
        ex. MySQL
        
        장점 - 쓸데없는 데이터 안들어옴
        
        **NoSQL** : 칸이 없고 걍 들어오는대로 쌓는것 
        ex. mongoDB
        
        장점 - 유연하게 대처 가능. 따라서 초기 스타트업 등에서 사용 
        (참고로 NoSQL이 not only SQL)
        
        </aside>
        
        <aside>
        👉 ********************DB트렌드********************
        
        클라우드에 DB를 저장하면 유저가 몰리거나, DB를 백업해야하거나, 모니터링하기가 아주 용이하다
        
        mongoDB Atlas
        클라우드 환경에서 mongoDB가 제공해주는 컴퓨터를 빌려다 쓰는것.
        
        </aside>
        
    - mongoDB 사용법 (패키지 : pymongo, dnspython)
        
        <aside>
        👉 파일-설정- + 들어가서 pymongo, dnspython 설치
         
        엑셀을 파이썬으로 조작하려면 특별한 라이브러리가 필요하다.
        마찬가지로 mongoDB 프로그램 조작하려면 pymongo 라는 특별한 라이브러리가 필요하다.
        
        </aside>
        
        <aside>
        👉 pymongo 사용법
        
        3줄 복사해넣기
        (mongo atlas 안에 dbsparta 라는 폴더가 있다?)
        
        ```python
        from pymongo import MongoClient
        client = MongoClient('mongodb+srv://test:sparta@cluster0.irnxuca.mongodb.net/cluster0?retryWrites=true&w=majority')
        #몽고db 에서 "Connect" 누른 후 application code 긁어옴
        #test가 아이디 sparta가 비번 cluster0 프로젝트 이름
        db = client.dbsparta
        ```
        
        사용하기
        (mongo atlas 안의 dbsparta 에 users 가 있다? )
        
        ```python
        from pymongo import MongoClient
        client = MongoClient('mongodb+srv://test:sparta@cluster0.irnxuca.mongodb.net/cluster0?retryWrites=true&w=majority')
        #몽고db 에서 "Connect" 누른 후 application code 긁어옴
        db = client.dbsparta
        
        # 저장 - 예시
        doc = {'name':'bobby','age':21}
        db.users.insert_one(doc)
        # users 대신 movies 이런거로 넣을곳 세팅가능
        
        # 한 개 찾기 - 예시
        user = db.users.find_one({'name':'bobby'})
        
        # 여러개 찾기 - 예시 ( _id 값은 제외하고 출력)
        all_users = list(db.users.find({},{'_id':False}))
        
        # 바꾸기 - 예시
        db.users.update_one({'name':'bobby'},{'$set':{'age':19}})
        
        # 지우기 - 예시
        db.users.delete_one({'name':'bobby'})
        
        # 전체지우기 - 예시
        db.users.delete_many({"type": 'hotel'})
        # 해당도큐먼트를 모두 삭제한다.
        db.users.delete_many({})
        #모든 도큐먼트 삭제
        
        # #몽고db 에서 browse Collections 에서 확인가능
        # #users 라는 collection 안 보면 bob 27 들가있는거보임임
        ```
        
        📌**mongo atlas 여기에 저장됨**
        
        [https://cloud.mongodb.com/v2/6377930cee017824702791d0#metrics/replicaSet/6377948bb037c339c2c31ed0/explorer/dbsparta/mars/find](https://cloud.mongodb.com/v2/6377930cee017824702791d0#metrics/replicaSet/6377948bb037c339c2c31ed0/explorer/dbsparta/mars/find)
        
        </aside>
        
- 🌟 **서버 (패키지 : flask, request, jsonify)**
    - DB와 서버의 차이?
        
        server: 내가 이해하기로는 server는 역할에 가깝다.즉, 다른 컴퓨터에 필요한 것들을 대신 수행해주면 그것은 server라고 하는것같다.한마디로 다른 컴퓨터가 필요한 것을 대신 수행해주는 컴퓨터가 server, 그것을 요청하는 컴퓨터는client(손님)이 된다.server의 예로는 다른 컴에서 좋아요를 누르면 다른컴퓨터에 알람이 가게 하거나 여럿이 참여할 수 있는 게임을 열어주거나 위치와 목적지를 받으면 걸리는 시간을 대략적으로 설명해 주거나 하는것을 뜻한다.
        
        그럼 DB는 무엇일까??DB란 database인데 이걸 보려고 들어온 사람은 없을것이다.db는 무형의 것인데 server처럼 실체가 있지않은 데이터 뭉치라고 생각한다.db를 식당에 비유하자면 식당에서 제공할 수 있는 메뉴중 하나이다.어떤 식당은 중식을 팔고, 어떤 식당은 양식을 팔듯이 어떤 서버은 db를 제공한다.그럼 그게 db server이다.한마디로 db를 제공하는 server인 것이다.
        
        그럼 DBMS는 무엇일까?데이터 베이스를 관리하는 것을 DBMS라고하는데 database management system 이라고 하는데식당에 비유하자면 음식 레시피 라던지 각각 고유의 식당 규칙 같은 것을 말한다.DBMS의 대표적으로는 MYSQL이 있다.
        
    - 프레임워크란? (패키지 : FLASK)
        
        <aside>
        👉 서버를 만든다는 것은 어려운일. 서버를 구동시켜주는 편한 코드 모음이 프레임워크
        
        마치 3분요리/소스 세트같은것. 프레임워크 안쓰면 태양초빻아서 고추장만드는격?
        
        </aside>
        
        <aside>
        👉 FLASK
        파이썬에서 flask 설치
        
        ```python
        from flask import Flask, render_template
        app = Flask(__name__)
        
        @app.route('/')
        def home():
           return render_template('index.html')
        
        # return이후 <button>나는 버튼이다</button> 이런 html 만들면 서버에서 다줌
        # 근데 귀찮으니 index.html 만들어 templates 폴더에 넣고 위에 헤더에 
        # render_template 놓고,
        # 여기에 이렇게 return render_template('') 써서 불러오는식으로 ok
        
        # 한편 그냥 html 파일 연것은 내 컴퓨터에 있는 파일을 연것.
        
        @app.route('/mypage')
        def mypage():
           return 'This is Mypage!!!'
        
        if __name__ == '__main__':
           app.run('0.0.0.0',port=5000,debug=True)
        ```
        
        이후 [http://localhost:5000/](http://localhost:5000/mypage) 혹은 [http://localhost:5000/mypage](http://localhost:5000/mypage) 치면 내 컴퓨터에 서버가 만들어진것을 확인가능
        
        </aside>
        
    - 프레임워크 로 서버만들기 - AJAX로 GET POST 요청받아보기 
    (패키지 : request, jsonify)
        
        <aside>
        👉 클라이언트 → 서버 요청시
        
        HTTP 라는 통신 규약을 따른다. HTTP request method 통해서 어떤 요청 종류인지 서버쪽에 정보를 알려줘야 한다.
        (마치 은행 창구에 개인고객이냐 기업고객이냐 얘기하면 처리가 다른것처럼)
        
        GET은 ‘영화목록 조회’ 같이 데이터를 조회(READ) 할 때 쓰임
        *데이터 전달시 URL 뒤에 물음표 붙여 key=value 로 전달한다
        *예:google.com?q=북극곰
        
        POST는 ‘회원가입, 회원탈퇴, 비번수정’ 같이 데이터를 생성(Create), 변경(Update), 삭제(Delete) 요청할 때 
        *데이터 전달시 바로 보이지 않는 HTML body에 key:value 형태로 전달한다
        
        </aside>
        
        <aside>
        👉 jsonify
        
        서버에서 jsonify 를 주면 이는 html 에서 response 찍고 받아야함
        
        ```python
        return jsonify({'msg': '헉헉 다받아서 서버다넣음수고'})
        ```
        
        ```html
        //$.ajax( ... 중략
        
        success: function (response) {
                            alert(**response['msg']**)
                            alert('서버가 그러는데 이거저장됐데잉')
                        }
        
        )
        ```
        
        </aside>
        
        - **GET 요청 예시**
            
            <aside>
            👉 **GET 요청 예시**
            
            <HTML>
            
            ```html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            <!--Jquery 불러옴-->
                <script>
                function hey(){
                    $.ajax({
                        type: "GET",
                        url: "/test?title_give=봄날은간다",
                        // /test라는 창구에 가는데 title_give 라는 이름으로 봄날은간다라는 데이터를 갖고 갈게
                        data: {},
                        success: function (response) {
                            console.log(response)
            						// 잘된다면 너가 주는 데이터를 콘솔에다 찍어볼게
                }
              //  get요청용 ajax Jquery 를 불러옴.
            
              })
                }
                </script>
            
            </head>
            <body>
                <h1> 성진 첫 웹페이지!!</h1>
                <button onclick="hey()">버튼만들기롱 </button>
            </body>
            </html>
            ```
            
            <Python>
            
            ```python
            from flask import Flask, render_template, **request, jsonify**
            app = Flask(__name__)
            
            @app.route('/')
            def home():
               return render_template('index.html')
            # http://localhost:5000/ 에서확인
            
            # return 이후  <button>나는 버튼이다</button> 이런거 다 눌르면 홈페이지에 뜸
            # 서버가 나한테 웹 페이지를 준것!
            # 한편 그냥 html 파일 연것은 내 컴퓨터에 있는 파일을 연것.
            
            # 근데 귀찮으니 index.html 만들어 templates 폴더에 넣고 위에 헤더에 render_template 놓고,
            # 여기에 이렇게 return render_template('') 써서 불러오는식으로 ok
            
            @app.route('/test', methods=['GET'])
            def test_get():
               title_receive = request.args.get('title_give')
               #title_give 라는 이름으로 받아와서 title_receive에 넣는다.
               print(title_receive)
               return jsonify({'result':'success', 'msg': '이 요청은 GET!'})
            # 얘네가 창구, GET 요청시의 API 역할을 해주는
            # request, jsonify 는 헤더에 추가해주시고
            
            if __name__ == '__main__':
               app.run('0.0.0.0',port=5000,debug=True)
            ```
            
            결과
            
            ![[localhost:5000](http://localhost:5000) 에서의 페이지. ](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2036.png)
            
            [localhost:5000](http://localhost:5000) 에서의 페이지. 
            
            ![[localhost:5000](http://localhost:5000) 안의 별도 test 창구의 이미지](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2037.png)
            
            [localhost:5000](http://localhost:5000) 안의 별도 test 창구의 이미지
            
            </aside>
            
        - **POST 요청 예시**
            
            <aside>
            👉 **POST 요청 예시**
            
            <HTML>
            
            ```html
            function post_hey(){
                    $.ajax({
                        type: "POST",
                        url: "/test ",
                        data: {title_give: '봄날은간다'},
                        success: function (response) {
                            console.log(response)
                        }
                      })
                }
            ```
            
            <Python>
            
            ```python
            from flask import Flask, render_template, request, jsonify
            app = Flask(__name__)
            
            @app.route('/')
            def home():
               return render_template('index.html')
            # http://localhost:5000/ 에서확인
            
            # return 이후  <button>나는 버튼이다</button> 이런거 다 눌르면 홈페이지에 뜸
            # 서버가 나한테 웹 페이지를 준것!
            # 한편 그냥 html 파일 연것은 내 컴퓨터에 있는 파일을 연것.
            
            # 근데 귀찮으니 index.html 만들어 templates 폴더에 넣고 위에 헤더에 render_template 놓고,
            # 여기에 이렇게 return render_template('') 써서 불러오는식으로 ok
            
            @app.route('/test', methods=['GET'])
            def test_get():
               title_receive = request.args.get('title_give')
               #title_give 라는 이름으로 받아와서 title_receive에 넣는다.
               print(title_receive)
               return jsonify({'result':'success', 'msg': '이 요청은 GET!'})
            # 얘네가 창구, GET 요청시의 API 역할을 해주는
            # request, jsonify 는 헤더에 추가해주시고
            
            @app.route('/test', methods=['POST'])
            def test_post():
               title_receive = request.form['title_give']
               print(title_receive)
               return jsonify({'result':'success', 'msg': '이 요청은 POST!'})
            
            if __name__ == '__main__':
               app.run('0.0.0.0',port=5000,debug=True)
            ```
            
            결과
            
            ![[localhost:5000](http://localhost:5000) 에서 콘솔 띄우고 버튼만들기 눌러본 모습](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2038.png)
            
            [localhost:5000](http://localhost:5000) 에서 콘솔 띄우고 버튼만들기 눌러본 모습
            
            </aside>
            

### 배포

프론트의 요청에 항상 응답해줄 수 있는 서버가 필요함.

외부접속이 가능하게 한 후 내 컴퓨터를 서버로 사용하게도 할 수 있음

컴퓨터가 항상 켜져있는 상태로 프로그램이 실행되어야 하는데 옛날에는 컴퓨터 다 사서 키보드 마우스 빼고 놓음

요즘엔 남의 클라우드시스템으로 인터넷세상에 있는 남의 컴퓨터를 빌려서 그걸 계속 돌려둔다.

(몽고 db 도 그의 일종)
이렇게 되면 트래픽대응도 편하고 여러가지 서비스 붙이기 쉬워진다.

AWS 는 그런 클라우드 서비스이며 EC2 사용권을 구입하면 OS를 리눅스로 씀. 

대부분의 회사에서는 리눅스라는 OS가 깔린 컴퓨터를 구매한다. 

AWS : Amazon Web Service 
EC2 : Elastic Compute Cloud 

즉 EC2는 AWS에서 제공하는 클라우드 컴퓨팅 서비스

- **간단한 리눅스 명령어 모음**
    
    
    *** 팁! 리눅스 커널에서 윗화살표 누르면 바로 전에 썼던 명령어가 나옴**
    
    ```bash
    ls: 내 위치의 모든 파일을 보여준다.
    
    pwd: 내 위치(폴더의 경로)를 알려준다.
    
    mkdir: 내 위치 아래에 폴더를 하나 만든다.
    
    cd [갈 곳]: 나를 [갈 곳] 폴더로 이동시킨다.
    
    cd .. : 나를 상위 폴더로 이동시킨다.
    
    cp -r [복사할 것] [붙여넣기 할 것]: 복사 붙여넣기
    
    rm -rf [지울 것]: 지우기
    
    sudo [실행 할 명령어]: 명령어를 관리자 권한으로 실행한다.
    sudo su: 관리가 권한으로 들어간다. (나올때는 exit으로 나옴)
    ```
    
- **도메인이란?**
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2039.png)
    
    <aside>
    👉 도메인이란?
    
    IP 주소(Internet Protocol address) 란 컴퓨터 네트워크에서 장치들이 서로 인식하고 통신하기 위해 사용하는 특수번호
    오늘날 주로 사용되고 있는 IP 주소는 IP 버전 4 (IPv4) 주소. 그런데 이 주소가 부족해짐에 따라 길이를 늘린 IP 버전 6 (IPv6) 주소가 점점 널리 사용되는 추세)
    
    (IPv4는 000.000.000.000 각 세자리씩 한도막당 8비트 표현, 곧 32비트이며 2^32 주소 생성가능)
    
    즉 IP 주소는 인터넷에서만 사용되는 전화번호라고 생각할 수 있다. 
    
    이런 번호는 사람이 외우기가 어렵다. 
    
    </aside>
    
    <aside>
    👉 DNS 서버(네임서버) 란?
    
    그래서 우리는 기억하기 쉬운 고유한 ‘도메인 주소’ 를 만들어 사용하게 된다.
    (흔히 WWW.~ 시작되는 주소가 도메인임)
    
    마치 '전화번호부' 처럼 도메인과 IP주소를 연결해주는 역할을 하는 서비스, 그것이 바로 DNS(domain name resolution) 시스템이다.
    
    이러한 DNS시스템 안에서 IP와 도메인 매칭의 역할을 하는 것이 DNS서버이며 
    
    이를 다른 말로는 네임서버라고도 한다.
    
    [https://www.youtube.com/watch?v=2ZUxoi7YNgs](https://www.youtube.com/watch?v=2ZUxoi7YNgs)
    
    </aside>
    
- **포트란? - 기본 개념**
    
    사전지식 : 인터넷 프로토콜 슈트(Internet Protocol Suite)
    
    → 인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 통신규약(프로토콜)의 모음. 인터넷 프로토콜 슈트 중에서는 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고도 불림 (TCP : Transmission Control Protocol)
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2040.png)
    
    ---
    
    이러한 전송계층 프로토콜 (예를들어 위 그림에서 TCP나 UDP) 에서 포트를 주로 사용하며 포트는 ‘운영 체제 통신의 종단점’ 이며 ‘네트워크 서비스나 특정프로세스를 식별하는 논리단위’ 이다.
    
    쉽게말하면 포트란 ‘논리적인 접속 장소’ 이며 인터넷 프로토콜인 TCP/IP 를 사용할 때에는 클라이언트 프로그램이 서버 프로그램을 지정하는 방법으로 사용된다.
    
    네트워크 상에서 통신을 할 때 IP를 토대로 해당 서버에 있는 컴퓨터에 접근하는 것이다.
    
    그런데 대부분의 경우 하나의 컴퓨터에는 여러 개의 서버가 실행될 수 있고 여러 개의 서버가 실행되고 있다면, 어느 서버에 접속해야하는지 컴퓨터에 알려주어야하며 이때 사용되는것이 포트번호다.
    
    즉 포트란 서버 컴퓨터로 들어오는 문이다.
    
    **서버 컴퓨터의 집주소는 ip** 
    
    **서버 컴퓨터로 들어오는 문이 port**
    
    포트 번호는 IP주소와 함께 쓰이며 해당하는 프로토콜에 의해 사용된다.
    
    [ftp://000.000.000.000:](ftp://0.0.0.0/)80
    
    이렇게 IP주소와 함께 뒤에 : 을 붙여서 포트 번호를 표기하며 WWW URL은 기본적으로 80번 포트를 사용하므로 웹 브라우저는 이를 생략해도 받아들인다.
    
    포트 번호는 크게 세 종류로 구분된다.
    
    - 0번 ~ 1023번: [잘 알려진 포트](https://ko.wikipedia.org/wiki/%EC%9E%98_%EC%95%8C%EB%A0%A4%EC%A7%84_%ED%8F%AC%ED%8A%B8) (well-known port)
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2041.png)
    
    - 1024번 ~ 49151번: 등록된 포트 (registered port)
    - 49152번 ~ 65535번: 동적 포트 (dynamic port)
    
    잘 알려진 포트 번호의 대표적 예는 다음과 같다.
    
    - 20 : [FTP(data)](https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%BC_%EC%A0%84%EC%86%A1_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
    - 21 : FTP(제어)
    - 22 : [SSH](https://ko.wikipedia.org/wiki/SSH_%ED%8C%8C%EC%9D%BC_%EC%A0%84%EC%86%A1_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
    - 23 : [텔넷](https://ko.wikipedia.org/wiki/%ED%85%94%EB%84%B7)
    - 53 : [DNS](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)
    - 80 : [월드 와이드 웹](https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9) [HTTP](https://ko.wikipedia.org/wiki/HTTP)
    - 119 : [NNTP](https://ko.wikipedia.org/wiki/NNTP)
    - 443 : [TLS](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%AC%ED%8A%B8_%EB%A0%88%EC%9D%B4%EC%96%B4_%EB%B3%B4%EC%95%88)/[SSL](https://ko.wikipedia.org/wiki/SSL) 방식의 HTTP
    
    [[PORT] 서버에서 포트란? (인바운드/아웃바운드, Daemon)](https://rotoma-code.tistory.com/m/entry/PORT-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-%ED%8F%AC%ED%8A%B8%EB%9E%80-%EC%9D%B8%EB%B0%94%EC%9A%B4%EB%93%9C%EC%95%84%EC%9B%83%EB%B0%94%EC%9A%B4%EB%93%9C-Daemon)
    
    [http의 기본 포트가 80, https의 기본 포트가 443인 이유는 무엇일까?](https://johngrib.github.io/wiki/why-http-80-https-443/)
    
- **포트란? - 5000, 80,22 등등**
    
    포트 번호를 통해서 실행되는 어플리케이션을 식별할 수 있고 (서버 컴퓨터로 들어오는 문)
    ip주소를 통해서 해당 서버를 식별할 수 있다 (서버 컴퓨터의 주소)
    
    외부에서 80포트 또는 22포트를 통해서 EC2 인스턴스의 ip주소(서버)에 접속한다.
    
     5000포트(인스턴스에서 돌아가고 있는 어플리케이션인 파이썬 서버)로 접속한다.
    
    외부에서 접속할 때는 EC2 인스턴스의 퍼블릭 ip주소를 통해서 접속하는것
    (동일 네트워크상에 있는 것이 아닌 외부 네트워크에 접속할 때는 ip주소를 알아야 접속 가능합니다)
    80포트의 경우 http 통신을 위해 기본 포트가 80이기 때문에 열어주는 것입니다.
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2042.png)
    
- SSH란?
    
    SSH는 Secure Shell 의 줄임말로 원격 호스트에 접속하기 위해 사용되는 보안 프로토콜임.
    
    원격 접속 과정에서 비밀번호나 파일내용 등의 데이터를 탈취당하지 않기 위해 탄생한 기술임. 
    
    클라이언트와 서버는 각각의 키를 가지고 있으며 이를 이용해 연결 상대를 인증하고 데이터를 주고받는다.
    
    여기서 키를 생성하는 방식은 대칭키와 비대칭키(또는 공개 키)로 나뉘어지는데 우리가 사용하는 .pem 은 비대칭키 중 개인 키를 의마한다. (공개 키는 .pub 형식)
    
    [가비아 라이브러리](https://library.gabia.com/contents/infrahosting/9002/)
    
- gitbash란?
    
    gitbash 는 Unix shell 로 윈도우의 cmd, 맥의 터미널과 같은 역할이다.
    
- filezilla란? FTP란?
    
    AWS 라는 회사에서 EC2 (Elastic Compute Cloud) 라는 서비스상품을 우리가 이용하는데 이는 ubuntu 라는 리눅스 os 로 운영되는 가상 컴퓨터를 제공받는 것이고
    
    우리는 SSH방식을 이용해서 이 가상 컴퓨터와 소통을 하게되는데 좀 더 직관적인 파일전송(드래그앤 드랍)을 위해서 filezilla 라는 프로그램을 추가적으로 이용하는것.
    
    FTP는 파일전송 프로토콜이고 파일질라는 FTP가 맞다.
    파일질라에서 선택하는 protocol인 FSTP는 SSH를 이용해 파일전송을 하는 일종의 FTP다.
    
    파일질라로 가상 컴퓨터의 ubuntu 와 연결되는것
    

---

**1) AWS에서 서버를 구매한다**

 ****

```bash
https://ap-northeast-2.console.aws.amazon.com/ec2/v2/home?region=ap-northeast-2
```

(Name 을 sparta_web으로, Ubuntu 18.04 or 20.04를 선택해서 t2.micro 고름.

🔑Key를 발급받고 Launch Instance 로 서버를 만든다)

---

**2) EC2의 포트 뚫어주기 (1) - 가상의 내 컴퓨터에서 포트 설정?** 

SSH 를 준비한다.

SSH란 다른 컴퓨터에 접속할 때 쓰는 프로그램인데 보안이 뛰어난 특성이 있다.

접속할 컴퓨터의 22번 포트가 열려있어야 접속이 가능한데 AWS EC2의 경우 22번 포트가 열려있다.

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2043.png)

Mac은 ssh가 있어서 명령어로 바로 접근이 가능하지만 Window에는 ssh가 없으므로 
’git bash’ 라는 프로그램을 이용하게 된다.

```bash
ssh -i 받은키페어를끌어다놓기 ubuntu@AWS에적힌내아이피
```

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2044.png)

(Key fingerprint 관련 메세지가 나올 경우 Yes 를 입력한다. git bash 를 종료할 때는 exit 명령어를 입력해 접속을 끊는다)

---

**3) 서버 세팅하기**

우린 지금 막 컴퓨터를 구매한 상태. 여기에 세팅(업그레이드, DB설치, 명렁어 통일 등) 해줘야 본격적으로 이용할 때 편리하다.

```bash
# python3 -> python
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10
// python3 대신 python 을 쓰겠다?

# pip3 -> pip 
sudo apt-get update
sudo apt-get install -y python3-pip
sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1
// 패키지를 설치해주는 마법사 pip 

# port forwarding
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 5000
// 포트 포워딩, 포트를 뗴주는것임 80으로 들어온 애를 5000로 꽂아주겠다...?
```

---

**4) 파일 옮기기**

filezilla 를 설치하고 실행시켜서 내 html. python 파일을 옮겨준다.

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2045.png)

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2046.png)

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2047.png)

---

**5) 서버 실행하기**

gitbash 에서 해당 파일 루트로 들어가서 파이썬 파일을 실행시키면 서버가 돌아가는 것

```python
python app.py
```

다만 패키지를 설치해야한다. ubuntu 에서는 명령어로 패키지 설치작업을 할 수 있다.

```bash
pip install flask, pymongo, dnspython
```

---

********************************************6) EC2의 포트 뚫어주기 (2) - AWS EC2에서도 포트 설정?********************************************

EC2 서버(가상의 내 컴퓨터)에서 포트 설정하는 것외에도 AWS EC2에서도 자체적으로 포트를 또 뚫어줘야됨. 

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2048.png)

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2049.png)

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2050.png)

Security group 을 눌러 들어가 Edit inbound rules 를 선택한다.

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2051.png)

소스는 Anywhere IPv4 로 하고 SSH 외에 포트 5000, 80도 열어준다 

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2052.png)

→ 80포트: HTTP 접속을 위한 기본포트 // 손님들이 타고 오는 포트 

→ 5000포트: flask 기본포트 // 우리 서버용 포트…? 여기서 웹서비스가 실행되고 있음.

→ 27017포트: DB 접속 포트

→ 22포트: SSH // 내 노트북에서 뚫는…? 

🌟

사실 웹에는 80이 숨겨져있다
[http://naver.com에는](http://naver.com에는) [http://naver.com:80](http://naver.com:80) 

```bash
# port forwarding
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 5000
// 포트 포워딩, 포트를 뗴주는것임 80으로 들어온 애를 5000로 꽂아주겠다...?
```

아까 서버 세팅에서 얘네는 80으로 받아온 걸 5000으로 퉁쳐주는 애들

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2053.png)

---

**7) 서버 유지하기** 

Git bash 를 종료하면 SSH가 접속이 끊어지게 되고 프로세스가 종료되며 서버가 돌지 않는다.

아래는 원격 접속 종료하더라도 서버가 계속 돌게하는 코드

```bash
# 아래의 명령어로 실행하면 된다
nohup python app.py &
```

한편 서버를 끄고 싶으면 아래 코드 쓰면 된다

```bash
ps -ef | grep 'python app.py' | awk '{print $2}' | xargs kill
```

---

**8) 도메인 연결하기**

도메인을 구매한다는 것은 ‘네임서버’ 를 운영해주는 업체에 IP와 도메인 매칭 유지비를 내는 것. 

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2054.png)

외주

 신청 : 010 - 3838

컨설팅, 사업 문의 : 010 - 3838 - 

### PROJECT1 : 화성땅 구매

flask, pymongo, dnspython 설치 + request, jsonify?

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2055.png)

front-end 에서 이름과 주소 그리고 평수를 입력하면 서버에서는 그 정보를 POST 형식으로 받아서 데이터베이스 mongo atlas 에 저장한 후 ‘주문완료’ 라는 메세지를 되돌려줌.

또 로딩이 되면 GET 형식으로 서버에 데이터를 요청하고 서버는 데이터베이스 값들을 받아와서 그대로 프론트에 돌려주고 HTML은 그 값을 콘솔에 띄움.

- **HTML (클라이언트)**
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
            integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
            crossorigin="anonymous"></script>
    
        <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">
    
        <title>선착순 공동구매</title>
    
        <style>
            * {
                font-family: 'Gowun Batang', serif;
                color: white;
            }
    
            body {
                background-image: linear-gradient(0deg, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('https://cdn.aitimes.com/news/photo/202010/132592_129694_3139.jpg');
                background-position: center;
                background-size: cover;
            }
    
            h1 {
                font-weight: bold;
            }
    
            .order {
                width: 500px;
                margin: 60px auto 0px auto;
                padding-bottom: 60px;
            }
    
            .mybtn {
                width: 100%;
            }
    
            .order > table {
                margin : 40px 0;
                font-size: 18px;
            }
    
            option {
                color: black;
            }
        </style>
        <script>
            $(document).ready(function () {
                show_order();
            });
            function show_order() {
                $.ajax({
                    type: 'GET',
                    url: '/mars',
                    data: {},
                    success: function (response) {
                        // alert(response['orders'])
                        let rows = response['orders']
                        for (let i=0; i<rows.length; i++){
                            let name = rows[i]['name']
                            let address = rows[i]['address']
                            let size = rows[i]['size']
    
                            let temp_html= `<tr>
                                <td>${name}</td>
                                <td>${address}</td>
                                <td>${size}</td>
                            </tr>`
    
                            $('#body').append(temp_html)
                            console.log(name,address,size)
                        }
                    }
                });
            }
    
            function save_order() {
                let name = $('#name').val()
                let address = $('#address').val()
                let size = $('#size').val()
    
                $.ajax({
                    type: 'POST',
                    url: '/mars',
                    data: {name_give: name, address_give: address, size_give: size},
                    success: function (response) {
                        alert(response['msg'])
                        window.location.reload()
                    }
                });
            }
        </script>
    </head>
    <body>
        <div class="mask"></div>
        <div class="order">
            <h1>화성에 땅 사놓기!</h1>
            <h3>가격: 평 당 500원</h3>
            <p>
                화성에 땅을 사둘 수 있다고?<br/>
                앞으로 백년 간 오지 않을 기회. 화성에서 즐기는 노후!
            </p>
            <div class="order-info">
                <div class="input-group mb-3">
                    <span class="input-group-text">이름</span>
                    <input id="name" type="text" class="form-control">
                </div>
                <div class="input-group mb-3">
                    <span class="input-group-text">주소</span>
                    <input id="address" type="text" class="form-control">
                </div>
                <div class="input-group mb-3">
                    <label class="input-group-text" for="size">평수</label>
                    <select class="form-select" id="size">
                      <option selected>-- 주문 평수 --</option>
                      <option value="10평">10평</option>
                      <option value="20평">20평</option>
                      <option value="30평">30평</option>
                      <option value="40평">40평</option>
                      <option value="50평">50평</option>
                    </select>
                  </div>
                  <button onclick="save_order()" type="button" class="btn btn-warning mybtn">주문하기</button>
            </div>
            <table class="table">
                <thead>
                  <tr>
                    <th scope="col">이름</th>
                    <th scope="col">주소</th>
                    <th scope="col">평수</th>
                  </tr>
                </thead>
                <tbody id="body">
                  <tr>
                    <td>홍길동</td>
                    <td>서울시 용산구</td>
                    <td>20평</td>
                  </tr>
                  <tr>
                    <td>임꺽정</td>
                    <td>부산시 동구</td>
                    <td>10평</td>
                  </tr>
                  <tr>
                    <td>세종대왕</td>
                    <td>세종시 대왕구</td>
                    <td>30평</td>
                  </tr>
                </tbody>
              </table>
        </div>
    </body>
    </html>
    ```
    
- **Python (서버)**
    
    ```python
    from flask import Flask, render_template, request, jsonify
    app = Flask(__name__)
    
    from pymongo import MongoClient
    client = MongoClient('mongodb+srv://test:sparta@cluster0.irnxuca.mongodb.net/cluster0?retryWrites=true&w=majority')
    #몽고db 에서 "Connect" 누른 후 application code 긁어옴
    db = client.dbsparta
    
    @app.route('/')
    def home():
       return render_template('index.html')
    
    @app.route("/mars", methods=["POST"])
    def web_mars_post():
        name_receive = request.form['name_give']
        address_receive = request.form['address_give']
        size_receive = request.form['size_give']
        print(name_receive,address_receive,size_receive)
    
        doc = {'name': name_receive,
               'address': address_receive,
               'size': size_receive}
        db.mars.insert_one(doc)
        return jsonify({'msg': 'POST로 된거 받고 주문 완료띄울게!ㅎ'})
    
    @app.route("/mars", methods=["GET"])
    def web_mars_get():
        order_list = list(db.mars.find({}, {'_id': False}))
        return jsonify({'orders': order_list})
    
    if __name__ == '__main__':
       app.run('0.0.0.0', port=5000, debug=True)
    ```
    

### PROJECT2 : 스파르타피디아

flask, pymongo, dnspython 설치 + request, jsonify? (서버+DB)
request, bs4 설치(크롤링)

![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2056.png)

front end 에서 url, 별점, 코멘트를 post 형식으로 주면
서버에선 별점 코멘트는 그대로 저장하고 url 에서 크롤링 작업후 해당 url (영화사이트) 에서의 영화제목, 이미지, 설명 따와서 몽고DB에 저장함

참고로 기존 크롤링과 좀 다른작업을함. 메타코드 어쩌고저쩌고… 
네이버는 코드가접근할때랑 사람접근할때랑 좀 다르다나 어쩐다나…  

```python
import requests
from bs4 import BeautifulSoup

url = 'https://movie.naver.com/movie/bi/mi/basic.naver?code=191597'

headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'}
data = requests.get(url,headers=headers)

soup = BeautifulSoup(data.text, 'html.parser')

# print(soup)
# 여기에 코딩을 해서 meta tag를 먼저 가져와보겠습니다.

title = soup.select_one('meta[property="og:title"]')['content']
image = soup.select_one('meta[property="og:image"]')['content']
desc = soup.select_one('meta[property="og:description"]')['content']

print(title, image, desc)
```

그리고 HTML 에서 다시 새로고침하면 GET 방식으로 서버에 요청하고 서버는 mongoDB 저장해있던 정보를 싹 빼서 돌려줌.

그럼 HTML은 받아온 정보 분리해서 각 인터페이스 맞게 파파팍 띄워줌

- **HTML (클라이언트)**
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
              integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
                integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
                crossorigin="anonymous"></script>
    
        <title>스파르타 피디아</title>
    
        <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap" rel="stylesheet">
    
        <style>
            * {
                font-family: 'Gowun Dodum', sans-serif;
            }
    
            .mytitle {
                width: 100%;
                height: 250px;
    
                background-image: linear-gradient(0deg, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('https://movie-phinf.pstatic.net/20210715_95/1626338192428gTnJl_JPEG/movie_image.jpg');
                background-position: center;
                background-size: cover;
    
                color: white;
    
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
    
            .mytitle > button {
                width: 200px;
                height: 50px;
    
                background-color: transparent;
                color: white;
    
                border-radius: 50px;
                border: 1px solid white;
    
                margin-top: 10px;
            }
    
            .mytitle > button:hover {
                border: 2px solid white;
            }
    
            .mycomment {
                color: gray;
            }
    
            .mycards {
                margin: 20px auto 0px auto;
                width: 95%;
                max-width: 1200px;
            }
    
            .mypost {
                width: 95%;
                max-width: 500px;
                margin: 20px auto 0px auto;
                padding: 20px;
                box-shadow: 0px 0px 3px 0px gray;
    
                display: none;
            }
    
            .mybtns {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
    
                margin-top: 20px;
            }
    
            .mybtns > button {
                margin-right: 10px;
            }
        </style>
        <script>
            $(document).ready(function () {
                listing();
            });
    
            function listing(){
                $.ajax({
                    type: 'GET',
                    url: '/movie',
                    data: {},
                    success: function (response) {
    
                        info = response['info']
    
                        for (i=0; i < info.length; i++) {
    
                            let comment = info[i]['comment']
                            let star = info[i]['star']
                            // 클라이언트에서 얘네 받쥬
    
                            let title = info[i]['title']
                            let image = info[i]['image']
                            let desc = info[i]['desc']
                            // 클라이언트에서 url 받고 거기서 title, image, desc 짜냄
    
                            let star_image='🧡'.repeat(star)
    
                            let 붙여 = `<div class="col">
                                            <div class="card h-100">
                                                <img src=${image} <- 이거 image
                                                     class="card-img-top">
                                                <div class="card-body">
                                                    <h5 class="card-title">${title} <-이거 타이틀</h5>
                                                    <p class="card-text">${desc} <-이거 영화 설명충</p>
                                                    <p>${star_image} <- 얘네 별개수 표시염ㅎㅎ</p>
                                                    <p class="mycomment">${comment} <- 여기 커멘트염 </p>
                                                </div>
                                            </div>
                                        </div>`
                            $('#cards-box').append(붙여)
                        }
    
                    }
                })
            }
    
            function posting() {
                alert('받을준비조진다')
    
                let url = $('#url').val()
                let star = $('#star').val()
                let comment = $('#comment').val()
                alert('받는다아')
    
                $.ajax({
                    type: 'POST',
                    url: '/movie',
    
                    data: {sample_url: url, sample_star: star, sample_comment: comment},
                    success: function (response) {
                        alert(response['msg'])
                        alert('서버가 그러는데 이거저장됐데잉')
                    }
                });
            }
    
            function open_box() {
                $('#post-box').show()
            }
    
            function close_box() {
                $('#post-box').hide()
            }
        </script>
    </head>
    
    <body>
    <div class="mytitle">
        <h1>내 생애 최고의 영화들</h1>
        <button onclick="open_box()">영화 기록하기</button>
    </div>
    <div class="mypost" id="post-box">
        <div class="form-floating mb-3">
            <input id="url" type="email" class="form-control" placeholder="name@example.com">
            <label>영화URL</label>
        </div>
        <div class="input-group mb-3">
            <label class="input-group-text" for="inputGroupSelect01">별점</label>
            <select class="form-select" id="star">
                <option selected>-- 선택하기 --</option>
                <option value="1">⭐</option>
                <option value="2">⭐⭐</option>
                <option value="3">⭐⭐⭐</option>
                <option value="4">⭐⭐⭐⭐</option>
                <option value="5">⭐⭐⭐⭐⭐</option>
            </select>
        </div>
        <div class="form-floating">
            <textarea id="comment" class="form-control" placeholder="Leave a comment here"></textarea>
            <label for="floatingTextarea2">코멘트</label>
        </div>
        <div class="mybtns">
            <button onclick="posting()" type="button" class="btn btn-dark">기록하기</button>
            <button onclick="close_box()" type="button" class="btn btn-outline-dark">닫기</button>
        </div>
    </div>
    <div class="mycards">
        <div class="row row-cols-1 row-cols-md-4 g-4" id="cards-box">
            <div class="col">
                <div class="card h-100">
                    <img src="https://movie-phinf.pstatic.net/20210728_221/1627440327667GyoYj_JPEG/movie_image.jpg"
                         class="card-img-top">
                    <div class="card-body">
                        <h5 class="card-title">영화 제목이 들어갑니다</h5>
                        <p class="card-text">여기에 영화에 대한 설명이 들어갑니다.</p>
                        <p>⭐⭐⭐</p>
                        <p class="mycomment">나의 한줄 평을 씁니다</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </body>
    
    </html></title>
    </head>
    <body>
    
    </body>
    </html>
    ```
    
- **Python (서버)**
    
    ```python
    from flask import Flask, render_template, request, jsonify
    app = Flask(__name__)
    # 서버만듦
    
    from pymongo import MongoClient
    client = MongoClient('mongodb+srv://test:sparta@cluster0.irnxuca.mongodb.net/cluster0?retryWrites=true&w=majority')
    db = client.dbsparta
    # db 만듦
    
    import requests
    from bs4 import BeautifulSoup
    
    # 크롤링 베이스 만듦
    
    @app.route('/')
    def home():
        return render_template('index.html')
    
    @app.route("/movie", methods=["POST"])
    def movie_post():
        sample_url = request.form['sample_url']
        sample_star = request.form['sample_star']
        sample_comment = request.form['sample_comment']
        # html 에서 받은 url, star, comment 저장
    
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'}
        data = requests.get(sample_url, headers=headers)
    
        soup = BeautifulSoup(data.text, 'html.parser')
    
        title = soup.select_one('meta[property="og:title"]')['content']
        image = soup.select_one('meta[property="og:image"]')['content']
        desc = soup.select_one('meta[property="og:description"]')['content']
        # ★★★ 여기는 크롤링해온것임!!
    
        doc = {'url': sample_url,
               'star': sample_star,
               'comment': sample_comment,
    
               'title': title,
               'image': image,
               'desc' : desc,
               }
        db.movies.insert_one(doc)
        # users 대신 movies 이런거로 넣을곳 세팅가능
    
        return jsonify({'msg': '헉헉 다받아서 서버다넣음수고'})
    
    @app.route("/movie", methods=["GET"])
    def movie_get():
    
        all_users = list(db.movies.find({}, {'_id': False}))
        return jsonify({'info': all_users})
    
    if __name__ == '__main__':
        app.run('0.0.0.0', port=5000, debug=True)
    ```
    

### PROJECT3 : 팬명록

flask, pymongo, dnspython 설치

### PROJECT4 : 버킷리스트

flask, pymongo, dnspython 설치

codeit 

- **프론트엔드 - React 웹 개발 시작하기**
    
    리액트는 페이스북 덩치가 커지다보니 개발 편하게 만드려고 쓰는거
    
    처음에는 구글 Angular 지금은 React (거의 프론트엔드 하고 싶으면 무조건써야. 리액트가 역사쓰는중) React 조금만 변경하면 React Native 로 앱개발도 가능
    
    ```java
    	npm init react-app . 
    // 마침표는 현재 디렉토리에서 만들겠다
    
    npm run start
    // 브라우저가 자동으로 열리면서 만든 프로젝트가 열림
    // https://localhost:3000 에서 확인!
    // 이 명령어는 파일을 수정하면 그걸 인식해서 바로바로 반영하는 기능도 한다(=개발모드를 실행했다)
    // ctrl+c 하면 페이지 꺼짐(=개발모드 종료했다)
    ```
    
    React 에서는 JS 코드 안에 html 용 태그 등을 섞어쓰는데 이런 문법을 JSX 라고 한다.
    
    - 크롬에서 개발자 도구를 통해 콘솔창 열듯이, 리액트 개발자 도구도 있다( React Developer Tools 크롬 확장프로그램임)
        
        ![들어가보면 Components, Profiler 생김](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2057.png)
        
        들어가보면 Components, Profiler 생김
        
        이 두 탭은 리액트로 만들어진 웹에서만 나타남. (페북 인스타도 리액트로만들어짐)
        
        ![컴포넌트 누르면 하이라이트됨](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2058.png)
        
        컴포넌트 누르면 하이라이트됨
        
    
    - index.html 과 index.js (개정전)
        
        ```jsx
        import ReactDOM from 'react-dom'
        
        ReactDOM.render(<h1>안녕 리액트!</h1>, document.getElementById('root'));
        
        //reactDOM 에서 default 로 export 하는 객체를 import 중 
        //getElementById 는 DOM 요소들 중에서 root라는 id 속성을 가져온다는 것
        //<h1></h1> 이 JSX 문법
        ```
        
        index.html 이 리액트코드중 가장먼저 실행됨.
        
        index.js 는 index.html 파일이 열리고 나서 실행되는 파일. 
        
        이렇게 render 함수 안에 첫번째 arguement 값을 바탕으로 새로운 html 요소를 만들고 
        
        그 요소를 두번째 arguement 에다가 집어넣는 방식으로 동작시켰음.
        
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
        		<meta charset="utf-8"/>
        		<title>주사위게임</title>
        	</head>
        
        	<body>
            <noscript>You need to enable JavaScript to run this app.</noscript>
            <div id="root"></div>
          </body>
        </html>
        ```
        
        index.js 에서 이렇게 코드쓴건 index.html 안에 있는 root 에 들어감
        
        즉 요기에다가 h1 태그를 넣어주는것임 
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2059.png)
        
        그 결과 이렇게 뜸. h1이 들어간거를 볼 수 있음
        
    - index.html 과 index.js (개정후)
        
        ```jsx
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import './index.css';
        import App from './App';
        import reportWebVitals from './reportWebVitals';
        
        //ReactDOM.render(<h1>안녕 리액트!</h1>, document.getElementById('root'));
        //이전 코드
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
        
        reportWebVitals();
        ```
        
        index.js 가 App.js 와 분리됨
        
        이전에는 ReactDOM.render에 💚태그와 🧡getElement 함수를 다넣었다면
        
        🧡ReactDOM.createRoot 로  root 객체를 만들어서 여긴 getElement 만 넣음
        
        💚JSX는 따로 App함수를 만들어서 root.render 안에서 콜함
        
        ⇒ 즉 App 함수 안에 태그를 따로만들고 createRoot 로 집어넣는 느낌인듯
        
        ```jsx
        import logo from './logo.svg';
        import './App.css';
        
        function App() {
          return (
            <div className="App">
              <header className="App-header">
                <h1>안녕 리액트!</h1>
                <img src={logo} className="App-logo" alt="logo" />
                <p>
                  Edit <code>src/App.js</code> and save to reload.
                </p>
                <a
                  className="App-link"
                  href="https://reactjs.org"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Learn React
                </a>
              </header>
            </div>
          );
        }
        
        export default App;
        ```
        
        즉 얘네들이 JSX 문법인듯
        
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
              name="description"
              content="Web site created using create-react-app"
            />
            <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
            <!--
              manifest.json provides metadata used when your web app is installed on a
              user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
            -->
            <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
            <!--
              Notice the use of %PUBLIC_URL% in the tags above.
              It will be replaced with the URL of the `public` folder during the build.
              Only files inside the `public` folder can be referenced from the HTML.
        
              Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
              work correctly both with client-side routing and a non-root public URL.
              Learn how to configure a non-root public URL by running `npm run build`.
            -->
            <title>React App</title>
          </head>
          <body>
            <noscript>You need to enable JavaScript to run this app.</noscript>
            <div id="root"></div>
          </body>
        </html>
        ```
        
        요기 id=”root” 대신에 App함수의 return 안 JSX 코드들이 대체됨!!
        
        ReactDOM의 createRoot 함수로 생성된 root 객체의 render 함수에 의해서!!
        
        ---
        
        💨💨💨 다시 한번 복습💨💨💨
        
        ```jsx
        import ReactDOM from 'react-dom'
        
        ReactDOM.render(<h1>안녕 리액트!</h1>, document.getElementById('root'));
        
        (원래는 이렇게 ReactDOM.render 에다가 다집어넣었쥬?)
        ```
        
        ```jsx
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import './index.css';
        import App from './App';
        import reportWebVitals from './reportWebVitals';
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
          <React.StrictMode>
            <App />
            <App2 />
          </React.StrictMode>
        );
        
        (이렇게 root 객체를 써서 분리 시켜줬쥬)
        ```
        
    
    JSX는 JS 에서 html을 편리하게 활용하게 함. 
    
    - Fragment 태그 잘 활용하면 불필요한 div 태그 줄일수있음. 잘쓰임
        
        jsx 안은 태그 하나에 다 감싸야함. 만약 두 개 이상 태그가 쓰여지면 오류남 이렇게
        
        ---
        
        ERROR in [eslint]
        src\App.js
        Line 23:8:  Parsing error: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>? (23:8)
        
        webpack compiled with 2 errors
        
        ---
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2060.png)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2061.png)
        
        그래서 이렇게 감싸줘야 하는데 div 태그 ㅅㅂ 쓰기싫다?
        
        Fragment 태그 쓰면됨
        
        ```jsx
        import logo from './logo.svg';
        import './App.css';
        import { Fragment } from 'react';
        
        function App() { 
          return (
            <Fragment className="App">
              <header className="App-header">
                <h1>C컵 여배우급 보지들을 무료로 따먹는 사이트</h1>
                <img src={logo} className="App-logo" alt="logo" />
                <p>
                  Edit <code>src/App.js</code> and save to reload.
                </p>
                <a
                  className="App-link"
                  href="https://reactjs.org"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Learn React
                </a>
              </header>
            </Fragment>
            
          );
        }
        
        export default App;
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2062.png)
        
        자연스럽게 안의 것부터 들어가는걸볼수있음
        
        ```jsx
        import logo from './logo.svg';
        import './App.css';
        
        function App() { 
          return (
            <>
            <div className="App">
              <header className="App-header">
                <h1>tt</h1>
                <img src={logo} className="App-logo" alt="logo" />
                <p>
                  Edit <code>src/App.js</code> and save to reload.
                </p>
                <a
                  className="App-link"
                  href="https://reactjs.org"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Learn React
                </a>
              </header>
            </div>
            </>
          );
        }
        
        export default App;
        ```
        
        이렇게 축약형 문법 <> </> 으로 쓸 수도 있당
        
    
    - JSX에서 html 코드와 JS 함께 사용하는 방법  (중괄호, 카멜케이스)
        - 중괄호로 넣기! (JS 표현식만 쓴다. if, for, 함수선언은 안됨)
            
            - react 에서는 JSX문법 활용하기 때문에 eventhandler 등록할때 addeventlistner 보다는 요소의 **속성**값으로 중괄호 넣어서 이벤트헨들러를 등록한다
            
            -역시 img 태그에 src(source) 속성값전달하는 것도 이 중괄호를 이용하는것
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2063.png)
            
        
        - 정리하면!
            
            `on`접두사가 붙었을때는 이 prop에 실제 이벤트가 연결되어 있으며, 
            `handle`접두사가 붙은건 이벤트가 발생했을 때 호출되는 실제 function을 의미한다고 생각하면 됩니다.
            
            - Props의 경우 : 보통 `onClick`과 같이 `on`접두사를 지정합니다.
            - Function Names의 경우: 보통 `handleClick`과 같이 `handle`접두사를 지정합니다.
            
            이 두 경우를 함께 사용한 결과 코드는 이런 패턴을 가지겠죠
            
            `<Component onClick={handleClick}/>`
            
        - 단, JSX에서 속성명은 카멜케이스로 쓴다는 것 !
        (단 data 속성은 카멜케이스 아닌 기존 html 문법대로 작성한다)
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2064.png)
            
        
        - 중괄호 안에는 파일경로 안넣깅. 이미지 깨짐 오류난다
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2065.png)
            
        
    - JSX는 JS의 확장문법이라 html 문법을 ‘완전히’ 쓸 수 없다 (class,for 등 바로 못씀)
        - class는 className으로
        
        ```jsx
        class Dice {
        	roll() {
        		console.log('Roll!');
        	}
        }
        
        // 즉 요런식으로 객체지향 개념으로 Dice 라는 class 를 선언하지만 
        
        function App() { 
          return (
            <div className="App">
        			...
            </div>
          );
        }
        
        // JSX 에서 쓸 때는 className으로 정의를 한다
        ```
        
        - for 문은 htmlFor 으로
        
        ```jsx
        function App() { 
          return (
            <form>
        			<label htmlFor="name">이름<label>
        			<Input id="name"> type="text" />
            </form>
          );
        }
        
        // 마찬가지로 html 에서 for 속성은 label 태그에서 input 태그와 함꼐 사용됨
        // JS에서는 for 를 쓰지만 JSX에선 htmlFor 라고 사용함
        ```
        
        - eventHandler 는 카멜케이스로
        
        ```jsx
        function App() { 
          return (
            <form>
        			<label htmlFor="name">이름<label>
        			<Input id="name" type="text" onBlur="" onFocus="" onMouseDown="">/>
            </form>
          );
        }
        
        // html 에서 onblur="" onfocus="" onmousedown="" 이렇게 소문자로 eventhandler를 작성했지만 JSX에서는 대문자로 작성해주기
        // 이를 camel case 라고 한다 (중간중간 대문자 넣는게 낙타등처럼 생겨서 하는말)
        ```
        
        이런 속성명들을 모두 외울 필요는 없고 VScode에 추천기능에 다 있음
        
    
    - 리액트 엘리먼트와 리액트 컴포넌트
        
        **리액트 엘리먼트**
        
        ---
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2066.png)
        
        이렇게 html 을 객체에 담을 수 있다.
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2067.png)
        
        콘솔찍어보면 객체가 나오는데 리액트에서는 html이 담긴 이 객체를 리액트 엘리먼트라고함
        
        이 리액트 엘리먼트를 ReactDOM에 render 메소드로 전달하게 되면 리액트가 이 객체를 해석해서 html로 랜더링을 하는 것.
        
        리액트엘리먼트는 리엑트로 화면을 구성하는데 가장 기본 핵심적인 것.
        
        **리액트 컴포넌트**
        
        ---
        
        리액트 엘리먼트를 단순히 html 이 아닌 함수형태로 만들면 JSX 문법 작성할때 태그처럼 활용가능.
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2068.png)
        
        이 때 이 함수(=태그)를 컴포넌트라고 한다.
        
        개발할 땐 리엑트 엘리먼트를 리액트 컴포넌트로 만들어서 활용하는데
        
        반드시 **(1) 함수이름 첫글자를 대문자로** 써야하고 **(2) JSX로만든 리액트 엘리먼트를 리턴해야**함
        
        그래야 컴포넌트가됨
        
        - 아예 페이지화 하기 ㅋ
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2069.png)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2070.png)
        
        JS를 HTML에 옮겨넣는(아마도?) index.js 파일에서 얘네들도 태그이지
        
        왜냐하면 html 엘리먼트를 출력하는 함수를 App.js 따로 만들었고 import 하는식으로 가져온거니까.
        
        (위에선 같은 페이지에서 함수만들어서 가져온거고 이건 그냥 import해서 함수가져온거고) 
        
    
    - 리액트 props
        
        ```jsx
        <Dice color="blue"/>
        
        이렇게 color 속성 지정해서 컴포넌트 만들기 가능
        
        ------------ 
        function Dice(props) {
        	console.log(props);
        	return <img blabla/>;
        }
        
        export default Dice;
         
        -------------
        이렇게 컴포넌트 띄워보면 콘솔에서 {color: "blue"} 확인가능
        (=이런 **객체**를 확인할 수 있음)
        ```
        
        리액트에서는 이렇게 속성을 지정가능한데 각각을 prop 이라하고 통칭해서 props 라함
        
        컴포넌트에 지정한 속성은 하나의 **객체형태**로 컴포넌트함수의 첫번째 파라미터로 전달된다
        
        얘네는 리액트 컴포넌트에 지정해준 속성이기 때문에 개발자도구에서 확인이 안된다.
        
        (개발자도구 → 설치해줫던 React Develop Tools 의 component 에서 확인가능함)
        
        ```jsx
        const DICE_IMAGES = {
        	blue : [diceBlue01, diceBlue02, ... ],
        	red : [diceRed01, diceRed02, ... ],
        }; 
        
        function Dice( { color = "blue", num = 1 } ) {
        	const src = DICE_IMAGES[color][num-1];
        	const alt = `${color} ${num}`;
        	return <img src={src} alt={alt} />;
        }
        
        // 컴포넌트 만듦
        // props 를 빼먹을 수도 있으니까 초기값지정해줌 blue, 1 
        
        ...
        <Dice color ="red" num={2} /> 
        ...
        
        // 이렇게 콜
        **// JS 에서 숫자를 쓰고 싶으면 중괄호로 써야됨!!!!!**
        ```
        
        📌 function test(props) 이렇게 props 로 전체 받고, {props.A}, {props.B} …. 이런식으로 적용가능한듯
        
    - 리액트 childeren prop
        
        
        JSX 작성시 **단일 태그**가 아니라, 
        
        **여는 태그와 닫는 태그의 형태로 작성**되면 그 안에 작성된 코드가 이 children 값에 담긴다.
        
        ```jsx
        기존코드
        function Button({text}){
        	return <button>{text}</button>
        }
        
        요렇게 선언후 
        아래와 같이 이용
        ...
        <Button text="던지기" />
        <Button text="처음부터"/>
        ...
        ```
        
        ```jsx
        Children prop 이용
        
        function Button({children}){
        	return <button>{children}</button>
        }
        
        요렇게 선언후 
        아래와 같이 버튼 닫아서 이용할 수 있음
        ...
        <Button> 던지기 </Button>
        <Button> 처음부터 </Button>
        ...
        ```
        
        이렇게 하고 콘솔찍어보면 Button 리액트 개발자 도구에서
        
        props에  children : “던지기” , children “처음부터” 이렇게 뜸
        
        (원래는 text : “던지기”)
        
        **📌 children 값 활용하면 좋은점?**
        
        JSX 로 컴포넌트 작성시, 
        → 단순 정보 전달할 때는 props 속성값 주로 활용
        
        → 화면에 보여질 모습을 직관적 코드로 작성하고자 할 때 children 값 활용
        
        - *children 활용하면 단순 텍스트 작성을 넘어 컴포넌트 안에 컴포넌트 작성할 수도 있고 컴포넌트 안에 복잡할 태그를 더 작성할 수도 있다…?
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2071.png)
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2072.png)
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2073.png)
            
    
    - 리액트 state
    이미지를 바꾸고 싶다면 html 자체를 여러개 만들어 이동하거나 이미지 주소를 바꿔줘야함
        
        
        리액트에서는 state쓰면 해결
        
        ```jsx
        import {useState} from 'react' // 이렇게 react 에서 가져와야함
        
        [num, setNum]=useState(1); // 이런식으로 useState는 파라미터로 초기값전달받고 함수실행후 배열형태로 요소 두개 리턴
        ```
        
        예시코드
        
        ```jsx
        import { useState } from 'react';
        import Butto from './Button';
        import Dice from './Dice';
        
        function random(n) {
        	return Math.ceil(Math.random()*n);
        }
        
        function App() {
        	const [num, setNum] = useState(1);
        // num에 초기값1 쳐넣쥬?
        
        	const handleRollClick = () => {
        		const nextNum = random(6);
        		setNum(nextNum);
        	};
        // 난수생성한 숫자를 num 에 쳐넣쥬? 곧 화면 바뀌겠쥬?
        
        	const hnadleClearClick = () => {
        		setNum(1);
        // 이 함수는 handleClearClick 눌렀을때만 동작하겠쥬?
        
        	};
        }
        ```
        
    
    - 참조형 state
        
        
        배열은 기본형이 아니라 참조형
        
        배열  자체를 값으로 갖는게 아니라 배열을 가리키고 있는 주소 값을 갖는거
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2074.png)
        
        이렇게 하면 상식적으로 gameHistory 값이 바뀌었으니 화면..
        
        아무리 메소드를 이용해 새로운 요소가 추가된 배열을 담아도 요소가 추가되기전과 이후 배열의 주소값이 같기때문에 state가 변경됐다고 생각하지 않는다.
        
        (콘솔 찍어보면 gameHistory 값은 변경안됨)
        
        그래서 리액트입장에서도 state가 바뀌어야 새로운 화면을 렌딩하게되는데 gameHistory 자체가 변하지않으므로(주소값이 동일하니) 멀뚱멀뚱 동작안함
        
        따라서 전체를 새로 만들어야 한다.
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2075.png)
        
        이렇게 빈배열안에서 gameHistory state 를 펼쳐주고 새로추가할 요소를 붙여주면 간단히 새로운 배열이 만들어진다. 
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2076.png)
        
        완성!
        
        이처럼 참조형 타입의 state를 만들때는
        
        메소드나 할당연산자로 값을 바꾸는게 아니라 반드시 새로운값을 만들어서 변경해야한다 
        
    - 컴포넌트가 좋은 이유
        
        리액트 개발은 컴포넌트 개발이다.
        
        → 반복적인 일이 줄어듦. 고장났을 때 고치기 쉽다. 일을 쉽게 나눌 수 있다.
        
        → 부품은 모여서 더 큰 부품이 될 수 있다.
        
    - state reputing
        
        자식 컴포넌트에 있던 state 를 부모 컴포넌트로 올려주는 것.
        
        그렇게 변수를 state로 올리고 props 로 내려주면됨
        
    - virtual DOM
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2077.png)
        
        (JS 구현) 여러 요소 직접 업데이트. 번거롭고 버그발생쉬움
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2078.png)
        
        (React 구현) 직접 요소변경이 아닌 state 변경으로 **아예 새로 렌더링**함. 
        
        새로운 state값이 적용된 엘리먼트를 리턴하게됨 
        (어디가 변경됐는지 알 필요도 없이 새로 랜더링)
        
        ---
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2079.png)
        
        html요소들은 DOM트리라는 자료구조로 저장
        
        리액트는 이를 본따서 만든 virtual DOM 을 사용
        
        엘리먼트를 새로 렌더링할 때 그 모습을 바로 DOM으로 반영하는게 아니라 virtual DOM 에다 일단 적용.
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2080.png)
        
        state 가 변경되면 App 컴포넌트 아래를 모두 지우고 App 컴포넌트를 새로 렌더링하는식으로 동작하였음.
        
        리액트는 state 변경 전 후 virtual DOM 을 비교해서 ‘바뀐 부분’만 렌더링한다.
        
        -이렇게 하면 개발자가 DOM노드를 신경쓸 필요가 없어서 무슨 데이터를 어떻게 보여줄지만 생각하며 단순하고 깔끔한 코드를 작성할 수 있음.
        
        -변경사항등을 리액트가 적당히 모아서 처리할 수 있음(Virtual DOM에 적당히 일감을 적당히 모아서 전달하니) 그래서 페북메신저같은 데서도 ‘한정된 브라우저 자원’을 효율적으로 이용할 수 있다.
        
        리액트와 유사한웹기술들을 Virtual DOM 사용하고 있다
        
        → 효율적인 화면처리가 가능
        
    - 인라인 style
        
        ```html
        <head>
            <style>
                **.mytitle {
        					width: 166px;
        				  height: 166px;
        					background-color: transparent;
                 }**
        
            </style>
        </head>
        
        <body>
        		<div class="mytitle"></div>
        </body>
        ```
        
        **”CSS 따로 만들 땐 html 스타일(문자열) 로 작성했노”**
        
        문자열로 정의중
        
        → head 의 style 태그안에 . 으로 정의하고 
        
        → 세미콜론; 으로 닫노
        
        → background-color 이렇게 슬래쉬 - 로 찍노 
        
        → 따로 ‘ ‘ 같은거 안쓰노
        
        ```jsx
        **const style = { 
        					width: '166px',
        				  height: '166px',
        					backgroundColor: 'transparent',
        };** 
        
        // 얘네 {속성 : '값'} 임
        **// background-color 썼던 html 과 달리 camelCase 로 적음을 유의**
        
        function Button () {
        	return (
        		<button style={style}> </button>
        	);
        }
        
        export default Button;
        ```
        
        **”인라인스타일로 만들 땐 객체를 만들어서 작성하노”**
        
        객체로 css 정의하는 react
        
        → const style 로 객체를 만드노
        
        → 쉼표 처리하노
        
        → 속성 value 들은 ‘ ‘ 로 처리하노
        
        *이렇게 만든 객체들이 style={style} 이렇게 jsx 구문안에 들어감.
        
        ```jsx
        const common = {
        	padding: '14px 27px',
        	borderRadius: '30px',
        }
        
        const blueButton = {
        	...common,
        color: 'blue',
        };
        
        const redButton = {
        	...common,
        color: 'red',
        };
        
        //이런식으로 서로 다르게 적용해야할 스타일만 각 개체에 따로 적용가능
        
        function Button ({children, onClick, color}){
        	**const style = color === 'red' ? redButton : blueButton;**
        	return ( 
        		<button style = {style} onClick = {onClick}>
        			{children}
        		</button>
        	);
        }
        
        //color prop 에 따라 style 다르게 찍어주는
        ```
        
        인라인스타일 style={style} 일케 바로안넣고 컴포넌트안에서  객체불러서 쓸수도있네
        
    - CSS 클래스네임1 - 태그에 바로 적용
        
        ```jsx
        body {
          background-color:black;
        }
        ```
        
        얘는 앞에 . 안붙이고 세미콜론; 으로 닫노 ****
        
        (이렇듯 따로 css 적용할때는 html css 스타일로함)
        
        **왜 . 찍지않노?**
        
        💡 **body 에 들어가고 있음. 다시말해서 html 의 body 태그에 먹이는 css 를 정의한 것임!** 
        
        💡 **비슷한 맥락으로 div { … } 이렇게 정의하면 돔전체 div 에 이 스타일을 먹이는 것**
        
        ```jsx
        import './index.css';
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
          <React.StrictMode>
            <App />
            {/* <App2/> */}
          </React.StrictMode>
        );
        
        ```
        
        **import Index form ‘./index.css’;** 이렇게 안하고 
        
        **import ‘./index.css’;** 로 바로 먹이노
        
        (css 에서 @import 는 다른 스타일파일을 임포트하는거다)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2081.png)
        
        이러면 콘솔찍었을 때 html style 안에 바로 들어가노
        
    - CSS 클래스네임2 - 클래스를 만들어 적용
        
        ```jsx
        .Button {
        	padding: 14px 27px;
        	border-radius: 9999px;
        }
        
        .Button.blue {
        }
        
        .Button.red {
        }
        ```
        
        **왜 . 찍노?**
        
        **💡 .App 은 클래스 선택자임.** 
        
        ```jsx
        **import './Button.css';**
        
        // const common = {
        //	padding: '14px 27px',
        //	borderRadius: '30px',
        // }
        
        // const redButton ={
        // ...common,
        // color: 'red',
        // };
        
        // const blueButton = {
        //	...common,
        // color: 'blue',
        // };
        
        function Button ({children, onClick, color = 'blue'}){
        **// 혹시 실수로 color prop 전달 안했을때 undefined 될수있으니 기본값으로 blue를 지정**
        // const style = color === 'red'? redButton : blueButton;
        // 얘가 아까 인라인스타일
        	**const buttonstyle =`Button ${color}`;**
        **//클래스명을 추가할 때 빈 공백이 필요하다! 공백없다면 하나의 클래스가 된다**
        
        	return ( 
        //		<button style = {style} onClick = {onClick}>
        // 얘가 아까 인라인스타일
        		**<button className={buttonStyle}** onClick = {onClick}>
        			{children}
        		</button>
        	);
        }
        
        ```
        
        css를 따로 정의를 해도 import 하고,
        
        🔥백틱이용해 const button = `Button blue` 이런식으로 css 에서 import 한 것을 객체에 담을 수 있나봄 (.Button.blue == ‘Button blue’)
        
        ---
        
        cf. JS에서 백틱을 사용하면 ${}를 사용해서 문자열과 변수를 적절히 같이 사용할 수 있었다.
        
        ```
        const num1 = 10;
        const num2 = 20;
        
        console.log(`${num1} + ${num2} = ${num1+num2} 입니다.`);
        ```
        
    - CSS 클래스네임을 이용한 상속
        
        마진과같이 외부적으로 영향을 끼칠만한 속성은 위에서 다루는 것이 좋다.
        
        ```jsx
        .App .App-button {
        	margin: 6px;
        }
        ```
        
        **[상위 컴포넌트에서 className 으로 먹이기]**
        
        ```jsx
        import './App.css';
        
        function App() {
        
        	return(
        		<div **className="App"**>
        			<Button **className="App-Button"** color="blue"> </Button>
        		</div>
        	);
        
        }
        ```
        
        이렇게하면 className 이라는 prop을 통해서 div엔 App, 버튼엔 App-Button 이라는 클래스가 생기고 App.css 파일에 작성한 스타일이 잘 적용됨
        
        **[하위컴포넌트에서 백틱으로 받아 먹고 인라인스타일 이용해 적용]**
        
        ```jsx
        **import './Button.css';**
        
        function Button ({children, onClick, color = 'blue', **className = ''}**){
        //안쓸수도있으니 빈거넣음
        
        	**const buttonstyle =`Button ${color} ${className}`;**
        
        	return ( 
        		****<button className={buttonStyle} onClick = {onClick}>
        			{children}
        		</button>
        	);
        }
        ```
        
        내부에서는 className 으로 정의한 App-button 을 클래스로 받고 이는 css에서 정의한 문자열이니 백틱안에 우겨넣고 이를 buttonstyle 이라는 객체로 받아서 버튼 속성에서 { } 안에 집어넣음
        
        **이렇게 하면 component 태그를 작성할때 전달한 className이라는 prop 이 html 태그의 className 속성을 사용하는듯한 결과로 이어지겠죠?**
        
        이렇게하면 자식요소들간의 여백을 조절할 수 있으니까 직관적
        
        버튼 내부 스타일은 안에서(여기선 Button) 적용하지만 마진같이 외부적으로 적용될거는 이렇듯 부모 컴퍼넌트(여기선 App)에서 다루는 것이 좋다
        
        🔥 css에서 .A.B 이렇게 정의한 것을 가져온다면
        
        인라인 스타일로는 button =  `A ${B}' 이렇게 객체로 받은다음 객체를 먹이고 
        
        클래스네임 스타일로는 상위태그에 “A” 하위태그에 “B” 이렇게 먹이는건가? (따로도 가능하네)
        
    - CSS 팁
        
        ```jsx
        function Button({ isPending, color, size, invert, children }) {
          const classNames = `Button ${isPending ? 'pending' : ''} ${color} ${size} ${invert ? 'invert' : ''}`;
          return <button className={classNames}>{children}</button>;
        }
        
        export default Button;
        ```
        
        이렇게 탬플릿 문자열 사용하면 자칫 길어질 수 있음
        
        ```jsx
        function Button({ isPending, color, size, invert, children }) {
          const classNames = [
            'Button',
            isPending ? 'pending' : '',
            color,
            size,
            invert ? 'invert' : '',
          ].join(' ');
          return <button className={classNames}>{children}</button>;
        }
        
        export default Button;
        ```
        
        이 때 배열을 사용하면 깔끔
        
        ```jsx
        import classNames from 'classnames';
        
        function Button({ isPending, color, size, invert, children }) {
          return (
            <button
              className={classNames(
                'Button',
                isPending && 'pending',
                color,
                size,
                invert && 'invert',
              )}>
             { children }
           </button >
          );
        }
        
        export default Button;
        ```
        
        더깔끔하게 하려면?
        
        위 예시 코드처럼 지저분하게 느껴지고, 매번 반복되는 코드를 작성한다는 번거로움이 있습니다. 개발자들은 이럴 때 라이브러리라는 걸 쓰는데요, 다른 개발자가 미리 만들어 놓은 코드를 이용해서 편하게 개발하는 겁니다.
        
        클래스네임의 경우에도 편리하게 사용할 수 있는 라이브러리가 많이 있는데요, 그중에서도 이번에 소개할 라이브러리는 바로 `classnames`라는 라이브러리입니다. 아래 예시 코드를 보시면 아시겠지만, 클래스네임에만 집중할 수 있어 훨씬 읽기 편해집니다. 이렇게 적절한 라이브러리를 쓰면 개발 생산성이 굉장히 좋아지죠.
        
        `classnames` 은 NPM이라는 프로그램을 통해 설치할 수 있습니다. 터미널에서 `npm install classnames` 을 입력하고 설치한 다음에, 위 예시처럼 `import` 로 불러와서 사용하면 됩니다. NPM 저장소 사이트로 들어가면 사용 방법과 설명이 나와있으니, 아래 링크를 한 번 살펴보시고 사용해보는 것도 좋을 것 같습니다.
        
        NPM classnames 패키지: [https://www.npmjs.com/package/classnames](https://www.npmjs.com/package/classnames)
        
    - CSS 호버관련
        
        **:hover**(마우스 올린 상태)나 **:focus**(입력창 포커스된 상태)같은 CSS에서 상태를 처리하는 경우에는 인라인 스타일로 할 수 없어서 꼭 CSS로 작성해야할 거 같아요!
        
        하지만 반대로 인라인 스타일에서만 할 수 있는 것들이 있는데 CSS 파일은 고정된 값으로 들어가지만 인라인 스타일은 자바스크립트라서 변하는 값을 지정할 수 있을 거 같습니다.
        
        어떤 사이트들은 아바타 이미지 올릴 때 보시면 잘라내기 한다던가 할 때 영역을 표시해주는데 이런건 변하는 값이라서 인라인 스타일을 쓰면 되지 않을까요?
        
        둘 다 쓸 수 있는 경우라면 CSS 클래스를 쓰는 게 CSS의 상속 기능이나 등등 다양한 것을 활용할 수 있어서 장점이 될 거 같습니다!
        
    
    - 빌드
        
        JSX는 웹브라우저가 해석못하니까 해석후 웹서버를 통해 제공되어야함.
        
        순수 JS 코드로 변환한 다음 웹서버를 통해제공하는데, 이 변환과정을 프론트엔드에서 ‘빌드’ 라고함
        
        ```jsx
        npm run build
        ```
        
        하면 build 파일이 생김. 이 파일들을 웹서버로 제공하면 프로젝트가 배포되는 것.
        
        ```jsx
        npx serve build
        ```
        
        npm 저장소에서 serve 라는 프로그램을 다운받고 build 폴더에서 서버를 실행하게됨
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2082.png)
        
        서버가 켜지면 터미널에 접속할 수 있는 주소가 나타남 
        (같은 무선공유기 사용하면 네트워크에 접속가능)
         
        
    - aws
        
        S3 : 구글드라이브 같은 저장소.
        
        S3 에 프로젝트에 올린다 (12개월 무료)
        
        [속성]
        
        S3 버킷만들고 정적웹사이트 호스팅 활성화 하면 
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2083.png)
        
        오류문서는 파일이 없는 경로로 접속하는 경우에 보여줄 html 파일
        
        index.html 로 하면 경로처리를 react 로 한다?
        
        [권한]
        
        버킷정책은 웹브라우저가 버킷으로 할 수 있는 권한을 설정하는것.
        
        버킷 정책의 정책생서기 버튼 누르면 정책을 만들 수 있다
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2084.png)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2085.png)
        
        만들어진 정책을 버킷 정책에 넣는다
        
        [객체]
        
        build 의 파일들을 업로드 
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2086.png)
        
        → 속성의 정적 웹사이트호스팅 밑의 주소가 우리 주소
        
        ---
        
        이후 도메인은 aws Route 53 이용할수있음
        
    - 도메인연결
        
        이번 노트에서는 AWS S3로 배포한 사이트에 커스텀 도메인을 연결하는 방법을 배워보겠습니다.
        
        도메인은 AWS를 통해서 구입할 수도 있고, 다른 도메인 등록 업체에서 살 수도 있는데요.
        
        구글에서 '도메인 구매'로 검색해서 마음에 드는 업체를 골라 구입하시면 됩니다.
        
        아직 도메인이 없는데 AWS를 통해 등록 하시려면 **1-a** 단계와 **2** 단계를 따라하시면 되고,
        
        만약 도메인을 이미 구입하신 분들이라면, **1-b** 단계와 **2** 단계를 따라하시면 됩니다.
        
        도메인 등록 비용과, AWS 서비스 이용료가 발생할 수 있으니 이점도 꼭 참고해주세요!
        
        # **1-a. AWS에서 도메인 구입하기**
        
        도메인 구입은 문득 들으면 굉장히 어려워보이지만,
        
        사실 인터넷으로 나이키 운동화를 사는 것처럼 쉽게 할 수 있습니다.
        
        우선 AWS로 접속해서 'Route 53'을 검색해 들어갑니다.
        
        Route 53을 사용하면 AWS로 도메인을 관리할 수 있는데요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-01.png&name=custom-domain-01.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-01.png&name=custom-domain-01.png)
        
        **도메인 > 등록된 도메인** 메뉴로 들어가면 위와 같은 화면이 나옵니다.
        
        여기서 **도메인 등록** 버튼을 클릭합니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-02.png&name=custom-domain-02.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-02.png&name=custom-domain-02.png)
        
        도메인 이름 선택 화면이 나오는데요.
        
        위 예시에서는 'codeit'이라는 도메인을 검색해봤습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-03.png&name=custom-domain-03.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-03.png&name=custom-domain-03.png)
        
        위 예시는 [react.pizza](http://react.pizza/) 라는 도메인을 구입하는 장면입니다.
        
        연락처 세부 정보에서 연락처를 입력하고, 안내에 따라 구매를 완료하시면 됩니다.
        
        여기서 자세한 설명은 생략하도록 하겠습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-04.png&name=custom-domain-04.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-04.png&name=custom-domain-04.png)
        
        도메인을 구입하고나서 Route 53에 있는 **호스팅 영역** 메뉴로 들어가보면,
        
        이렇게 아까 구입한 도메인이 호스팅 영역이란 걸로 생성됐을 겁니다.
        
        Route 53에서는 호스팅 영역을 단위로 도메인을 관리하는데요.
        
        여기서 도메인 이름을 클릭해보죠.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-05.png&name=custom-domain-05.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-05.png&name=custom-domain-05.png)
        
        AWS에서 알아서 설정해놓은 값들이 잘 보이네요!
        
        # **1-b. 다른 사이트에서 도메인을 구입한 경우**
        
        만약 다른 사이트에서 구입한 도메인을 AWS에서 관리하려면 몇 가지 설정이 필요합니다.
        
        이번 레슨에서는 AWS를 통해서 타사 도메인을 관리하는 설정을 해 볼 겁니다.
        
        우선 AWS로 접속해서 'Route 53'을 검색해 들어갑니다.
        
        Route 53이란 걸 사용하면 AWS로 도메인을 관리할 수 있습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-06.png&name=custom-domain-06.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-06.png&name=custom-domain-06.png)
        
        **호스팅 영역** 메뉴로 들어가면 위와 같은 화면이 나옵니다.
        
        Route 53에서는 호스팅 영역을 단위로 도메인을 관리하는데요,
        
        **호스팅 영역 생성** 버튼을 클릭해 도메인을 위한 호스팅 영역을 만들어 보겠습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-07.png&name=custom-domain-07.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-07.png&name=custom-domain-07.png)
        
        위 예시에서 저는 [react.pizza](http://react.pizza/) 라는 도메인을 관리하는 호스팅 영역을 만들고 있습니다.
        
        도메인 이름은 다른 사이트에서 구입한 도메인명을 적고,
        
        아래의 **호스팅 영역 생성** 버튼을 눌러서 생성합니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-08.png&name=custom-domain-08.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-08.png&name=custom-domain-08.png)
        
        그럼 이렇게 호스팅 영역이 만들어지고, 기본 값들이 설정된게 보이죠?
        
        여기서 레코드는 도메인을 서비스할 때 참고할 정보들인데요,
        
        여기서 **유형이 NS인 네임서버 레코드**에 주목해주세요.
        
        그리고 도메인을 구입하신 사이트에 들어가서, '**네임서버 설정**'을 해주어야 합니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-09.png&name=custom-domain-09.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-09.png&name=custom-domain-09.png)
        
        제가 이용하는 사이트에서는 이렇게 도메인 관리 페이지로 들어가면
        
        **커스텀 네임서버**를 설정할 수가 있었는데요.
        
        AWS 호스팅 영역에서 기본 값으로 생성된 레코드 중에서
        
        **NS 유형**에 해당하는 **값/트래픽 라우팅 대상**의 값을 복사해서
        
        커스텀 네임서버로 등록해줍니다.
        
        자. 그럼 네임서버 설정이 잘됐는지 확인해볼까요?
        
        [https://dnschecker.org](https://dnschecker.org/) 라는 사이트로 들어가서 확인해볼게요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-10.png&name=custom-domain-10.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-10.png&name=custom-domain-10.png)
        
        레코드 유형으로 **NS** 를 선택하고, 설정한 도메인 이름을 검색했습니다.
        
        초록색 체크 표시랑 함께 아까 설정한 NS 레코드 값들이 잘 보이네요.
        
        네임 서버 설정은 서비스마다 다르지만 **길면 하루 이틀 정도** 걸릴 수 있으니까,
        
        이점도 참고해주세요.
        
        # **2. A 레코드 등록하기**
        
        이제 Route 53의 호스팅 영역에 A 레코드를 등록해볼 겁니다.
        
        A 레코드는 웹 브라우저가 [react.pizza](http://react.pizza/) 라는 도메인 주소로 들어왔을 때,
        
        어떤 주소의 서버가 응답해 줄지 지정해주는 용도로 씁니다.
        
        우리의 경우에는 도메인 주소로 들어오면, AWS S3 버킷의 웹 사이트 엔드포인트가 응답해주면 되겠죠.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-11.png&name=custom-domain-11.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-11.png&name=custom-domain-11.png)
        
        앞에서 만든 호스팅 영역에서 **레코드 생성** 버튼을 클릭합니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-12.png&name=custom-domain-12.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-12.png&name=custom-domain-12.png)
        
        위 예시에서 저는 레코드 이름을 dicegame이라고 했는데요,
        
        [dicegame.react.pizza](http://dicegame.react.pizza/) 를 사용하려고 이렇게 만들었습니다.
        
        이런 식으로 도메인 앞에 뭐가 더 붙은 서브 도메인으로 만드셔도 좋고,
        
        레코드 이름을 그냥 비워두면 [react.pizza](http://react.pizza/) 처럼 최상위 주소로 A 레코드를 생성할 수 있습니다.
        
        레코드 유형은 A로 선택할게요.
        
        그리고 트래픽 라우팅 대상에서 별칭을 켜줍니다.
        
        별칭은 AWS에서 제공하는 기능인데요.
        
        우리가 만들어 놓은 S3 버킷의 엔드포인트(주소)를 직접 입력하지 않아도 되고,
        
        AWS 안에서 별명처럼 쓸 수 있게 해줍니다.
        
        위 예시에서 저는 처음에 버킷을 만들 때
        
        아시아 태평양(서울)에다가 `dicegame.react.pizza` 라는 이름으로 버킷을 만들었습니다.
        
        만약에 [react.pizza](http://react.pizza/) 라는 주소로 만들고 싶다면
        
        **버킷 이름도 반드시 `react.pizza` 로 해줘야 한다는 것에 주의하세요.**
        
        모두 설정하고 **레코드 생성** 버튼을 클릭하면,
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-13.png&name=custom-domain-13.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-13.png&name=custom-domain-13.png)
        
        호스팅 영역에 A 레코드가 생겼습니다.
        
        실제로 잘 적용됐는지 한번 확인해볼까요?
        
        [https://dnschecker.org](https://dnschecker.org/) 라는 사이트로 접속합니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-14.png&name=custom-domain-14.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-14.png&name=custom-domain-14.png)
        
        여기서 A 레코드를 선택하고, 저는 아까 만든 `dicegame.react.pizza` 라는 주소를 검색했습니다.
        
        초록색 체크 표시랑 아이피 주소가 잘 보이신다면 잘 적용된 겁니다.
        
        그럼 이제 웹 브라우저로 접속해볼까요?
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-15.png&name=custom-domain-15.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4660&directory=custom-domain-15.png&name=custom-domain-15.png)
        
        웹 브라우저에서도 잘 보입니다.
        
    
    - 브라우저는 어떻게 리액트를 알아들을까?
        
        ![트렌스파일링과 번들링은 모던 웹개발에서 자주사용하는개념](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2087.png)
        
        트렌스파일링과 번들링은 모던 웹개발에서 자주사용하는개념
        
        [트렌스파일링]
        
        바벨이라는 프로그램을 통해서 JSX 가 JS로 변환된다
        
        [babeljs.io](http://babeljs.io) 에서 try it out 가면 바벨 테스트할 수 있음
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2088.png)
        
        JSX 문법으로 작성한 부분이 JS로 바뀌는 모습 확인할 수 있다 
        
        이런과정을 ‘transfiling’ 이라 한다.
        
        바벨은 대표적인 tranfiler
        
        (vscode 에서 자동적으로 해주고 있다)
        
        ---
        
        [번들링]
        
        build 보면 js 파일들이 여러가지가 있는데 소스파일들을 압축해서 묶어놓은것
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2089.png)
        
        이런 묶음 파일을 번들이라고한다.
        
        이런 번들 파일로 만드는것을 ‘번들링’ 이라고 하는데 빌드하면서 자동으로 번들링되는것
        
    
    - PJT1. 주사위게임
    - PJT2. 가위바위보
    
- **프론트엔드 - React로 데이터 다루기**
    
    
    프로젝트 규모가 커지면 props, state 로 커버가 안됨.
    
    리액트에서는 Context 를 쓰게됨
    (props 를 거치지 않고 여러 컴포넌트에 데이터를 넘겨줄 수 있음)
    
    말 그대로 ‘맥락’, ‘상황에 대한 정보’ 인데 
    
    가령, 사용자가 한국어를 쓰다가 영어를 쓴다? 
    
    이럴 때 많은 컴포넌트들이 영어를 쓴다는 정보를 공유하겠죠?
    
    이 때 범위를 정해주는게 <Context.Provider />로 범위를 정하게 된다.
    
    provider 자손 컴포넌트에서는 props 거치지않고 데이터를 자유롭게 쓸 수 있다.
    
- **프론트엔드 - React로 웹사이트 만들기**
    
    “Single Page Application? Client-side Rendering? Server-side Rendreing?”
    
    html 로 개발하려면 html 파일을 페이지마다 하나씩 만들어줘야하는데..
    
    리액트는 **컴포넌트**를 이용해서 웹을 만든다 
    
    “React Router” - 여러 페이지를 **나누거나 이동**하는걸 컴포넌트로 깔끔하게 해줌
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2090.png)
    
    **React router 핵심 컴포넌트는 Router, Routes, Route, Link 가 있다.**
    
    ‘리액트 스러운 방법으로’ 컴포넌트를 사용해서 페이지를 나눠주게 된다.
    
    리액트 라우터는 패키지 쓴다.
    
    우리는 이미 react 와 react-dom 이라는 패키지를 쓰고 있다
    
    ```jsx
    npm install react-router-dom@6
    ```
    
    - **Router - 라우터의 시작**
        
        리액트 라우터에서 사용하는 데이터(현재주소, 페이지기록 등) 다 가지고있음
        
        Context 는 props 를 거치지않고 데이터를 내려주는데, 데이터를 내려줄 범위를 Context Provider 로 지정했쥬? 
        
        라우터 컴포넌트로 내부적으로는 Context Provider. 
        
        그래서 리액트 라우터에서 사용하는 기능을 사용하려면 라우터 ‘컴포넌트’ 안에서 사용해야함?
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2091.png)
        
        보통은 이렇게 최상위 컴포넌트에서 라우터를 감싸고 사용한다.
        
        **BrowserRouter 를 사용해 이 컴포넌트를 최상위 컴포넌트에서 감싸주면 모든 곳에서 사용할 수 있다.**
        
        이렇게하면 프로젝트 전체에서 리액트 라우터를 쓸 수 있다.
        
    - **Routes, Route - 페이지 나누기**
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2092.png)
        
        보통 이 컴포넌트들은 같이사용하는데 JS 에서 스위치 케이스문 같은 것임
        
        Route 에서 페이지 경로와 컴포넌트를 지정.
        
        Routes 컴포넌트 안에 Route 컴포넌트를 배치해서 각 페이지를 나눠줄 수 있다.
        
        Routes 안에서는 위에서부터 차례대로 Route 를 검사하는데 현재 경로와 path prop 이 일치하는 Route 를 찾는다.
        
        (예를들면 courses 경로로 들어왔을 때 차례대로 경로를 살펴보다가 맞는 경로를 찾으면 그 안에 있는 컴포넌트를 보여주게됨)
        
        ```jsx
        import { BrowserRouter, Routes, Route } from 'react-router-dom';
        import App from './components/App';
        import HomePage from './pages/HomePage';
        import CoursePage from './pages/CoursePage';
        import CourseListPage from './pages/CourseListPage';
        import WishlistPage from './pages/WishlistPage';
        
        function Main() {
          return (
            **// 최상위 컴포넌트인 Main.js 파일에서 라우터 컴포넌트를 적용하고 있다.**
            <BrowserRouter> 
              <App>
        **{/* routes 컴포넌트로 감싸서 여러개의 Route 컴포넌트를 배치하고 있다 */}**
                <Routes>
        {/* 슬래시라는 경로로 들어오면 Homepage라는 컴포넌트를 보여줌 
        다시말하면 path 속성으로 경로를 지정하고 element 속성으로 보여줄 컴포넌트를 지정
        컴포넌트 함수가 아니라 jsx를 넘겨준다는 점도 눈여겨보기*/}
        
        {/* Routes를 렌더링할 때 React router 는 Routes 안의 route를 차례대로 검사하면서 현재경로가 패스와 일치하는지 검사. 일치하는 경로를 찾으면 엘리먼트 속성으로 지정한 컴포넌트를 랜더링 */}
        
        {/* routes router 컴포넌트는 div 태그같은걸 랜더링하지않음. fragment 처럼 리액트상에만 존재하는 컴포넌트 */}
        
                  <Route path="/" element={<HomePage />} />
                  <Route path="courses" element={<CourseListPage />} />
                  <Route path="courses/react-frontend-development" element={<CoursePage />}/>
                  <Route path="wishlist" element={<WishlistPage />} />
                </Routes>
              </App>
            </BrowserRouter>
          );
        }
        
        export default Main;
        ```
        
    - **route 중첩 - 하위페이지 나누기**
        
        ## *하위 페이지 나누기 기본
        
        path 가 길어지고 복잡해질 때 하나의 routes 안에서 다루기는 복잡하다.
        
        그래서 route 안에서 중첩해서 사용할 수 있게 한다.
        
        ```
        import { BrowserRouter, Routes, Route } from 'react-router-dom';
        import App from './components/App';
        import HomePage from './pages/HomePage';
        import CoursePage from './pages/CoursePage';
        import CourseListPage from './pages/CourseListPage';
        import WishlistPage from './pages/WishlistPage';
        
        function Main() {
          return (
            // 최상위 컴포넌트인 Main.js 파일에서 라우터 컴포넌트를 적용하고 있다.
            <BrowserRouter> 
              <App>
                {/* routes 컴포넌트로 감싸서 여러개의 Route 컴포넌트를 배치하고 있다 */}
                <Routes>
                  {/* 슬래시라는 경로로 들어오면 Homepage라는 컴포넌트를 보여줌 
                  다시말하면 path 속성으로 경로를 지정하고 element 속성으로 보여줄 컴포넌트를 지정
                  컴포넌트 함수가 아니라 jsx를 넘겨준다는 점도 눈여겨보기*/}
        
                  {/* Routes를 렌더링할 때 React router 는 Routes 안의 route를 차례대로 검사하면서 현재경로가 패스와 일치하는지 검사
                  일치하는 경로를 찾으면 엘리먼트 속성으로 지정한 컴포넌트를 랜더링 */}
        
                  {/* routes router 컴포넌트는 div 태그같은걸 랜더링하지않음. fragment 처럼 리액트상에만 존재하는 컴포넌트 */}
                  <Route path="/" element={<HomePage />} />
        
                  <Route path="courses" element={<CourseListPage />} />
                  <Route path="courses/react-frontend-development" element={<CoursePage />}/>
        // 기존 코드
        
                  <Route path="courses">
                    <Route **index** elemnt={CourseListPage}/>}/>
                    <Route path="react-frontend-development" element={<coursePage/>}/>
                  </Route>
        // 하위에서 중첩
        
                  <Route path="wishlist" element={<WishlistPage />} />
                </Routes>
              </App>
            </BrowserRouter>
          );
        }
        
        export default Main;
        ```
        
        Route 로 컴포넌트를 감싸고 안의 최상위 element에는 path 대신 index 를 넣었다. 
        
        즉, 기존 courses의 페이지는 Index 속성으로 바뀌었고 courses 하위 것들은 밑으로 따로 빠짐.
        
        이런식으로 만들면 좋은점은 라우트가 많아졌을 때 경로나 용도에 따라서 분리할 수 있고 path 도 훨씬 간단해짐
        (courses 대신에 다른 경로쓰고싶다면 courses 가 있는 부모라우트만 변경하면됨)
        
        ## * 하위 route 여러개에서 공통된 디자인을 보여주고 싶을땐?
        (부모 Route 컴포넌트에 element 속성을 지정하고 Outlet 컴포넌트를 이용해 만든 페이지를 집어넣는다)
        
        ```jsx
        import { BrowserRouter, Routes, Route } from 'react-router-dom';
        import App from './components/App';
        import HomePage from './pages/HomePage';
        import CoursePage from './pages/CoursePage';
        import CourseListPage from './pages/CourseListPage';
        import WishlistPage from './pages/WishlistPage';
        
        function Main() {
          return (
            <BrowserRouter> 
              <App>
                <Routes>
                  <Route path="/" element={<HomePage />} />
                  <Route path="courses">
                    <Route index elemnt={<CourseListPage/>}/>
                    <Route path="react-frontend-development" element={<coursePage/>}/>
                  </Route>
                  <Route path="wishlist" element={<WishlistPage />} />
                </Routes>
              </App>
            </BrowserRouter>
          );
        }
        
        export default Main;
        ```
        
        ```jsx
        import { BrowserRouter, Routes, Route } from 'react-router-dom';
        import App from './components/App';
        import HomePage from './pages/HomePage';
        import CoursePage from './pages/CoursePage';
        import CourseListPage from './pages/CourseListPage';
        import WishlistPage from './pages/WishlistPage';
        
        function Main() {
          return (
            <BrowserRouter> 
                <Routes>
                  <Route path="/" element={<App/>}>
        
        **{/* App 컴포넌트는 공통 layout을 렌더링하는 컴포넌트. 
        App을 Routes 위에 놓아서 Route 들을 감싸면오류가 난다 Routes 의 하위컴포넌트들은 <Route> 혹은 <Fragment> 만 쓸 수 있기 때문
                    
        이 때이렇게 App을 element 속성으로 내려서 지정하고 지정된 컴포넌트에서는 Outlet 컴포넌트를 쓴다  */}**
        
                      <Route index element={<HomePage />} />
                      <Route path="courses">
                       <Route index elemnt={<CourseListPage/>}/>
                        <Route path="react-frontend-development" element={<coursePage/>}/> </Route>
                      <Route path="wishlist" element={<WishlistPage />} />
                </Routes>
            </BrowserRouter>
          );
        }
        
        export default Main;
        ```
        
        이럴 땐 element prop 을 지정하고
        
        ```jsx
        import Nav from '../components/Nav';
        import Footer from '../components/Footer';
        import styles from './App.module.css';
        import './App.font.css';
        import { Outlet } from 'react-router-dom';
        
        // 원래코드
        // function App({ children }){ 
        //  ...
        //   <div className={styles.body}>{children} </div>
        //  ...
        // }
        
        function App() {
          return (
            <>
            **{/* 라우터에서 랜더링되는 부분은 Outlet 컴포넌트가 있는 부분에 랜더링됨 */}
        원래는 App({children}) 이렇게 children 속성 받아서 outlet 에 집어넣어줬었음**
        
              <Nav className={styles.nav} />
              <div className={styles.body}><Outlet/></div>
              <Footer className={styles.footer} />
            </>
          );
        }
        
        export default App;
        ```
        
        지정된 컴포넌트에서는 outlet 컴포넌트를 사용하면 됩니다.
        
        routes 컴포넌트에서는 route 만 써야되기때문에 (App 컴포넌트 등 안쓰고) 이렇게한다!!
        
    - route - 없는 페이지 처리하기
        
        ```jsx
        {/* 모든 경로를 포함하는 route다. *는 와일드카드라서 모든 값을 다 포함한다는 의미. 차례대로 경로를 검사하다가 마지막에 이 페이지를 보여주게 되겠지. */}
                      <Route path="*" element={<NotFoundPage/>}/>
        ```
        
        경로를 찾을 수 없을 때 보이는 페이지 설정해보장 
        
    
    [페이지 이동 3종세트]
    
    - **Link (Navlink) - 사용자가 클릭해서 페이지 이동하기**
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2093.png)
        
        리액트에서 a 태그대신 사용하는것
        
        ```jsx
        import { Link } from 'react-router-dom';
        import Container from './Container';
        import UserMenu from './UserMenu';
        import logoImg from '../assets/logo.svg';
        import styles from './Nav.module.css';
        
        function Nav() {
          return (
            <div className={styles.nav}>
              <Container className={styles.container}>
                <Link to="/">
                  <img src={logoImg} alt="Codethat Logo" />
                </Link>
                <ul className={styles.menu}>
                  <li>
        {/* Link 컴포넌트에는 to 라는 속성을 사용함. 절대경로로 설정해서 localhost:3000/courses 로 이동하게 됨 
        만약 / 안붙이면 현재 주소의 맨마지막에 /courses 붙여서 움직임 A태그같은것임*/}
                    <Link to="/courses">카탈로그</Link>
                  </li>
                  <li>커뮤니티</li>
                  <li>
                    <UserMenu />
                  </li>
                </ul>
              </Container>
            </div>
          );
        }
        
        export default Nav;
        ```
        
        ```jsx
        import { Link } from 'react-router-dom';
        import Card from './Card';
        import CourseIcon from './CourseIcon';
        import Tags from './Tags';
        import getCourseColor from '../utils/getCourseColor';
        import styles from './CourseItem.module.css';
        
        const DIFFICULTY = ['입문', '초급', '중급', '고급'];
        
        function CourseItem({ course }) {
          const showSummary = course.summary && course.title !== course.summary;
          const courseColor = getCourseColor(course.code);
          const difficulty = DIFFICULTY[course.difficulty || 0];
          const thumbStyle = {
            borderColor: courseColor,
          };
        
          return (
            <Card className={styles.courseItem}>
              <div className={styles.thumb} style={thumbStyle}>
                <CourseIcon photoUrl={course.photoUrl} />
              </div>
              <div className={styles.content}>
                <h2 className={styles.title}>
                  <Link to={`/courses/${course.slug}`}>{course.title}</Link>
                </h2>
                <p className={styles.description}>{showSummary && course.summary}</p>
                <div>
                  <Tags values={[course.language, difficulty]} />
                </div>
              </div>
            </Card>
          );
        }
        
        export default CourseItem;
        ```
        
        데이터가 있는 mock.json 을 보면 코스마다 slug 라는 값이 있는데 각 데이터를 구분하는 고유한 문자열. 웹개발에서 id 보다 더 의미있는 주소를 만들 때 사용
        
        예를들어 Route 에서 path 는 “/courses/react-frontend-development” 이런식으로 되어있는데
        
        mock.json 가보면 courses 중 “slug” : “react-frontend-development” 이렇게 되어있는 항목이 있고 이 코스를 가져오게되는것
        
        (***Mock 이란*** ? 실제 객체를 다양한 조건으로 인해 제대로 구현하기 어려울 경우 가짜 객체를 만들어 사용하는데, 이를 ***Mock*** 객체라 한다.)
        
        한편, Navlink 는 link 와 같지만 style 속성으로 함수를 지정해줄수있다는 특징이 있다
        
    - **Navigate - 로그인이 안되면 다른페이지로 바로 리다이렉트**
        
        
        웹사이트 들어갔는데 로그인이 풀려서 로그인페이지로 이동하는 것.
        
        페이지에 접속했는데 어떤 이유때문에 다른 페이지로 접속하는것을 리다이렉트라고함
        
        **예시:**
        
        - 쇼핑몰의 회원 전용 페이지에 로그인없이 들어와서 로그인 페이지로 리다이렉트하는 경우
        - 쇼핑몰의 상품 상세 페이지에서 제품이 품절되었거나 삭제되어서 다른 페이지로 이동시키는 경우
        
        예를들어 course slug 로 받은 값이 잘못되어있다?
        
        이럴 때 코스목록 페이지로 이동(리다이렉트)시켜보자
        
        ```jsx
        **import { Navigate, useParams } from 'react-router-dom';**
        
        function CoursePage() {
          const { courseSlug }=useParams() 
          //리액트 라우터에서 제공하는 커스텀훅이다!
          //얘가 리턴하는 객체에는 현재 경로의 파라미터들이 저장되어 있는데 이 객체에 courseslug 라는 값도 있다.
          //destructuring 으로 courseSlug 값을 가져온다.
         
          //const course = getCourseBySlug('react-frontend-development');
          //위에서 react-frontend-develpoment 을 courseSlug 변수로 바꿈
          //이렇게 하면 이 컴포넌트에 있는 나머지 코드들은 courseSlug 값에 따라서 알맞은 코스데이터를 받아오고 렌더링하는 코드가 됨
          const course = getCourseBySlug(courseSlug);
          const courseColor = getCourseColor(course?.code);
        
          if (!course) {
            **return <Navigate to="/courses" />;**
          }
          
          const headerStyle = {
            borderTopColor: courseColor,
          };
        
          const handleAddWishlistClick = () => {
            addWishlist(course?.slug);
          };
        ```
        
    - **UseNavigate 로 페이지 이동하기 - 특정 코드가 실행이 끝나서 이동시키고 싶다면**
        
        코스 상세페이지에서 코스담기를 누르면 위시리스트에 코스추가되는 기능
        
        매번 추가할 때마다 페이지 이동하는 것은 이상하니까 버튼 눌렀을 때 알아서 이동하는 기능
        
        **예시:**
        
        - 쇼핑몰에서 장바구니에 담기를 눌렀을 때 리퀘스트를 보내고 장바구니 페이지로 이동시키는 경우
        - 쇼핑몰에서 결제하기 버튼을 누르고 나서 모든 결제가 완료된 후에 페이지를 이동시키는 경우
        - 리다이렉트된 로그인 페이지에서 로그인을 완료한 후에 처음 진입했던 페이지로 돌아가는 경우
        
        ```jsx
        import { addWishlist, getCourseBySlug } from '../api';
        import Button from '../components/Button';
        import Container from '../components/Container';
        import Card from '../components/Card';
        import CourseIcon from '../components/CourseIcon';
        import getCourseColor from '../utils/getCourseColor';
        import styles from './CoursePage.module.css';
        import { Link, Navigate, useParams, useNavigate } from 'react-router-dom';
        
        function CoursePage() {
          const { sex }=useParams() 
          const course = getCourseBySlug(sex);
          const courseColor = getCourseColor(course?.code);
        
          // 이때 react 에서는 usenavigate 라는 훅을 사용한다 (react-router-dom 에서 가져와야됨) 
          const navigate = useNavigate();
        
          if (!course) {
            return <Navigate to="/courses" />;
          }
        
          const headerStyle = {
            borderTopColor: courseColor,
          };
        
          // 코스 담기 버튼을 눌렀을 때 실행할 함수 
        
          const handleAddWishlistClick = () => {
          // 이거는 wishlist 에 추가하는 함수
            addWishlist(course?.slug);
        
          // 이동할 경로를 파라미터로 넘겨주고 실행하면 된다.
            navigate('/wishlist');
          };
        
          return (
            <>
              <div className={styles.header} style={headerStyle}>
                <Container className={styles.content}>
                  <CourseIcon photoUrl={course.photoUrl} />
                  <h1 className={styles.title}>{course.title}</h1>
                  <Button variant="round" onClick={handleAddWishlistClick}>
                    + 코스 담기
                  </Button>
                  <p className={styles.summary}>{course.summary}</p>
                </Container>
              </div>
              <Container className={styles.topics}>
                {course.topics.map(({ topic }) => (
                  <Card className={styles.topic} key={topic.slug}>
                    <h3 className={styles.title}>{topic.title}</h3>
                    <p className={styles.summary}>{topic.summary}</p>
                  </Card>
                ))}
              </Container>
            </>
          );
        }
        
        export default CoursePage;
        ```
        
    
     
    
    - **useParams - 동적인 경로 만들기**
        
        페이지가 많다고 path 를 다 일일이 설정하기가 힘들겠쥬?
        
        path 대신에 변수를 받으면 좋을것 같은데…? 
        
        동적인 경로로 바꾸자!!
        
        ```jsx
        import { BrowserRouter, Routes, Route } from 'react-router-dom';
        import App from './components/App';
        import HomePage from './pages/HomePage';
        import CoursePage from './pages/CoursePage';
        import CourseListPage from './pages/CourseListPage';
        import WishlistPage from './pages/WishlistPage';
        
        function Main() {
          return (
            <BrowserRouter> 
                <Routes>
                  <Route path="/" element={<App/>}>
                      <Route index element={<HomePage />} />
                      <Route path="courses">
                       <Route index elemnt={<CourseListPage/>}/>
        					 {/* <Route path="react-frontend-development" element={<coursePage/>}/> 온래 이거였는데 이거 코스리스트 마다 다 다른거쓰기엔 좀.. */}
                        <Route path=":courseSlug" element={<coursePage/>}/> </Route>
                      <Route path="wishlist" element={<WishlistPage />} />
                </Routes>
            </BrowserRouter>
          );
        }
        
        export default Main;
        ```
        
        이렇게 하면 courseSlug 라는 변수로 [**페이지 경로]** 를 받아올 수 있는데 이런걸 리액트 경로에서는 ‘파라미터’ 라고 부른다
        
        (경로파라미터를 지정하려면 저렇게 원하는 route 경로의 path 에 콜론 뒤에 원하는 이름을 적어주면됨)
        
        이렇게 하면 페이지 경로가 달라질 때마다 파라미터 값이 달라지니
        
        같은 컴포넌트라도 파라미터값에 따라 데이터만 다르게 보여줄 수 있음
        
        *요런 구현 아이디어는 웹개발에서 흔하게 활용되니 참고!!
        
        그러면 어떻게 이런 경로 파라미터를 불러올까??
        
        이제 courseSlug 를 받아오는 coursePage 에 들어가보자
        
        ```jsx
        import { addWishlist, getCourseBySlug } from '../api';
        import Button from '../components/Button';
        import Container from '../components/Container';
        import Card from '../components/Card';
        import CourseIcon from '../components/CourseIcon';
        import getCourseColor from '../utils/getCourseColor';
        import styles from './CoursePage.module.css';
        import { useParams } from 'react-router-dom';
        
        function CoursePage() {
          const { courseSlug }=useParams() 
          //리액트 라우터에서 제공하는 커스텀훅이다!
          //얘가 리턴하는 객체에는 현재 경로의 파라미터들이 저장되어 있는데 이 객체에 courseslug 라는 값도 있다.
          //destructuring 으로 courseSlug 값을 가져온다.
         
          //const course = getCourseBySlug('react-frontend-development');
          //위에서 react-frontend-develpoment 을 courseSlug 변수로 바꿈
          //이렇게 하면 이 컴포넌트에 있는 나머지 코드들은 courseSlug 값에 따라서 알맞은 코스데이터를 받아오고 렌더링하는 코드가 됨
          const course = getCourseBySlug(courseSlug);
          const courseColor = getCourseColor(course?.code);
        
        ...
        
          return (
        
        ...
        
          );
        }
        
        export default CoursePage;
        ```
        
        main 에서 사용했던 courseSlug 파라미터는 useParams 에서 불러온다.
        
        (가령 `~url~/test/1`  이라면 파라미터가 1이므로 courseSlug 에는 1이 저장된다)
        
        이렇게 경로에서 사용하는 동적인 값을 ‘파라미터’ 라고 부른다고 했다.
        
        이런 류의  파라미터를 모아놓은것을 params 다.
        
        useParams 라는 훅으로 params 객체를 가져온다
        
        그리고 그 정보를 courseSlug 라는 변수에 저장하는 것이다.
        
        ( useParams는 URL 인자들의 key/value(키/값) 짝들의 객체를 반환한다. 현재 <Route> 의 match.params에 접근하기 위해 사용한다. )
        
        (참고로 useParams 는 react-router-dom 패키지에서 가져와야함)
        
        요렇게 동적인 경로를 만들 수 있당
        
    - **useSearchParams - 쿼리 사용하여 검색 기능  만들기**
        
        -query 스트링을 받아서 검색어 기능을 만들거다-
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2094.png)
        
        ```jsx
        import { useSearchParams } from 'react-router-dom';
        import { getCourses } from '../api';
        
        function CourseListPage() {
        	//이 역시 react-router-dom 의 부분
          //리액트 라우터에서 제공하는 커스텀훅이다. 
          //리액트 라우터에서는 query 파라미터값을 가져오고 싶을때 이 훅을 사용할 수 있다.
          const [searchParams, setSearchParams] = useSearchParams();
        
        	//아래와 같이 사용하는데 searchParams 객체에서는 아래와 같이 keyword 파라미터 값 가져옴
        	//이것(searchParams.get('keyword')을 콘솔로 확인해보면 /courses 에서는 null 이 출력
          // /courses?keyword=react 이 주소로 들어가면 react 값이 출력됨
        
        	//이 keyword Query 파라미터 값을 initKeyword 변수에 집어넣고, 
          //state 의 초기값과 getCourses 파라미터로 넘겨줌!
        
          const initKeyword = searchParams.get('keyword');
        
          const [keyword, setKeyword] = useState(initKeyword || '');
        	const coures = getCourses(initKeyword);
        }
        ```
        
        1. useSearchParams 라는 커스텀 훅을 사용해 searchParams 객체와 setter  함수 정의한다.
        2. 가령 react 라는 값을 입력하면 serachparms에 keyword : react 라는 객체가 생긴다.
        3. 이를 searchParams.get 함수로 가져온다 query 파라미터 값을 가져올 수 있었다.
        4. 이 값을 사용해서 코스 목록에서 검색된 결과를 보여줬다.
        5. 쿼리값을 변경하고 주소를 이동하고 싶다면 setter 함수에 객체를 이렇게 넘겨주면 된다setter 함수로는 주소창에 query string 을 변경할 수 있는데 객체에 원하는 query 파라미터를 property 로 넣어서 변경한다
        
        ```jsx
          // [본격]
          // handleSubmit 는 이벤트 객체를 받아서 preventDefault 객체 실행
          // 이렇게 하면 submit 했을 때 웹브라우저가 저절로 페이지를 이동하지 않는다.
          // 기본 동작대신에 react 라우터를 통해 query 파라미터를 변경하는 이유? -> 
        
          // setSearchParams 는 파라미터로 객체를 받는다. 여기다가 원하는 query 파라미터를 객체 파라미터로 넘기면 된다
          // 아래와 같이 하면 keyword 파라미터에 값이 지정된다
          // 그런데 keyword 값이 없으면 query 파라미터로 null 같은게 저장되면 안되니까 keyword state 값이 없으면 빈객체로 넘겨주는것
          
        	const handleSubmit = (x) => { 
            x.preventDefault(); 
            setSearchParams(keyword ? {keyword,} : {});
          }
        
          const handleKeywordChange = (e) => setKeyword(e.target.value);
        
          return (
            <ListPage
              variant="catalog"
              title="모든 코스"
              description="자체 제작된 코스들로 기초를 쌓으세요."
            >
              {/* [본격] 입력form 을 submit 했을 때 주소창에 있는 query string 을 바꿔보자!!!  */}
              {/* <form className={searchBarStyles.form}> 바꾸기 전*/}
              <form className={searchBarStyles.form} onSubmit={handleSubmit}>
                <input
                  name="keyword"
                  value={keyword}
                  onChange={handleKeywordChange}
                  // input 태그에는 name 값을 keyword 로 지정했다 
                  // 값을 입력할 때마다 keyword 'state' 값이 변경된다. 
                  // form 태그는 엔터나 submit 버튼을 누르면 '쿼리' 와 함께 페이지를 이동하는 것이다. 
                  // 이걸 수정해서 검색 결과 보여주자
        
                  placeholder="검색으로 코스 찾기"
                ></input>
                <button type="submit">
                  <img src={searchIcon} alt="검색" />
                </button>
              </form>
        
              <p className={styles.count}>총 {courses.length}개 코스</p>
        
                {/* [마지막으로] course의 개수가 없을 때 검색결과가 없다는 것을 알려주는 메세지였다
                검색어가 있을 때라는 조건을 추가해주기 위해서 아래에 initKeyword 를 달았다.
                이렇게 하면 검색어가 있을 때 검색된 결과가 있으면 띄우고 없으면 경고메세지를 띄운다. */}
              {initKeyword && courses.length > 0 ? (
                <div className={styles.courseList}>
                  {/* getCourses 로 가져온 코스 목록 courses, 이것들을 각 요소마다 CourseItem 으로 랜더링 */}
                  {courses.map((course) => (
                    <CourseItem key={course.id} course={course} />
                  ))}
                </div>
              ) : (
        
                <Warn
                  className={styles.emptyList}
                  title="조건에 맞는 코스가 없어요."
                  description="올바른 검색어가 맞는지 다시 한 번 확인해 주세요."
                />
              )}
            </ListPage>
          );
        ```
        
        1. 
        
        검색어를 입력하면 주소에 /courses?keyword=react 이렇게 뒤에 뭔가가 붙여서(이것이 Query string 임. 주소에 추가적인 조건을 넣을때 사용) 페이지를 이동시킴
        
    - **useParams VS useSearchParams**
        
        [useParams 이용] - Path Variable
        
        ```jsx
        import { useParams } from "react-router-dom";
        const { id } = useParams();
        ```
        
        ```jsx
        function App() {
          return (
            <BrowserRouter>
              <div className="App">
                  <Route path='/diary/:id' element={<Diary />} />
                </Routes>
                <RouterTest />
              </div>
            </BrowserRouter>
          );
        ```
        
        [useSearchParams 이용] - Query String
        
        ```jsx
        import { useSearchParams } from "react-router-dom";
        
        const Edit = () => {
        
            const [searchParams, setSearchParams] = useSearchParams();
        
            const id = searchParams.get('id');
            const mode = searchParams.get('mode');
        
            console.log("id :", id, "/ mode : ", mode);
        };
        ```
        
    
    - SPA(싱글 페이지 애플리케이션) 이해하기
        
        리액트 라우터에서는 A태그 대신에 link 로 하이퍼링크를 만들었다
        
        웹브라우저에 기본 기능이 있는데 굳이 react router 통해서 페이지 이동하는 이유는
        
        우리가 만든게 SPA 이기 때문임.
        
    - React-helmet으로 페이지 제목 설정하기
        
        ```jsx
        <html lang="ko">
          <head>
            <meta charset="utf-8" />
            <title>Codethat</title>
            ...
          </head>
          <body>
            <div id="root" class="container">
              ...
            </div>
            <script src="/static/js/bundle.js"></script>
            <script src="/static/js/vendors~main.chunk.js"></script>
            <script src="/static/js/main.chunk.js"></script>
          </body>
        </html>
        ```
        
        자바스크립트로 페이지 제목을 바꾸려면 아래처럼 `document.title` 값을 수정하면 됩니다.
        
        ```
        document.title = 'Codethat - 커뮤니티';
        ```
        
        그런데 이 코드의 문제점은 페이지 제목이 어떻게 바뀌는지 알려면,
        
        관련된 코드를 차례대로 읽어봐야 한다는 단점이 있죠. 눈에 잘 띄지도 않고요.
        
        이것보다 좀 더 편리하게 리액트스러운 방법으로 제목을 바꿀 수 있는 방법이 있습니다.
        
        바로 `react-helmet` 이라는 라이브러리를 사용하는 건데요.
        
        ```jsx
        import { Helmet } from 'react-helmet';
        import Button from '../components/Button';
        import Container from '../components/Container';
        import Lined from '../components/Lined';
        import styles from './HomePage.module.css';
        import landingImg from '../assets/landing.svg';
        
        function HomePage() {
          return (
            <>
              <Helmet>
                <title>Codethat - 코딩이 처음이라면, 코드댓</title>
              </Helmet>
              <div className={styles.bg} />
              <Container className={styles.container}>
                <div className={styles.texts}>
                  <h1 className={styles.heading}>
                    <Lined>코딩이 처음이라면,</Lined>
                    <br />
                    <strong>코드댓</strong>
                  </h1>
                  <p className={styles.description}>
                    11만 명이 넘는 비전공자, 코딩 입문자가 코드댓 무제한 멤버십을
                    선택했어요.
                    <br />
                    지금 함께 시작해보실래요?
                  </p>
                  <div>
                    <Button>지금 시작하기</Button>
                  </div>
                </div>
                <div className={styles.figure}>
                  <img src={landingImg} alt="그래프, 모니터, 윈도우, 자물쇠, 키보드" />
                </div>
              </Container>
            </>
          );
        }
        
        export default HomePage;
        
        ```
        
        사용법은 정말 간단합니다.
        
        예를 들면 위 코드처럼 `Helmet` 이라는 컴포넌트로 감싼 다음에,
        
        안에다가 `<title>` 태그를 배치하면 이 컴포넌트가 렌더링 될 때
        
        HTML의 `<title>` 태그를 덮어쓸 수 있습니다.
        
        이름이 헬멧인 이유는 `<head>` 태그에 덮어쓰기 때문이죠 😆.
        
    

- **백엔드 - Node.js 기본기**
    
    # 1. Node.js 시작하기
    
    웹 브라우저에서 여러 요소 동적으로 움직이기 or 외부와 통신하기 위해 쓰는 언어가 JS
    
    node.js 는 웹브라우저뿐만 아니라 다른곳에서도 쓰게해주는 JS 실행환경? (=웹브라우저 밖에서도 JS쓸 수 있게함)
    
    node.js 를 배우면 JS만 알아도 하나의 웹서비스를 만들 수 있다.
    
     (예전에는 프론트는 JS+HTML,CSS 백엔드는 JAVA+PHP+Python 써야했음→근데 백엔드 JS 만들게 되면서 JS만 알아도 프론트 백 다가능하게됨)
    node.js 를 paypal, uber, likedin, netflix 등에서 쓰고 있음
    
    - 서버(웹브라우저나 모바일 앱으로 어떤 요청 보냈을 때 응답하는 컴퓨터) 에서 사용되는 프로그램 만들기
    - 데스크톱에서 실행되는 GUI 프로그램 만들기
    - 작은 로봇용 프로그램
    
    ```jsx
    console.log('Hellow Node.js');
    ```
    
    ```jsx
    node test.js
    
    (JS 빼도됨)
    ```
    
    js 를 만들고 터미널 현재 실행위치에서 위의 명령어를 입력하면  Hellow Node.js가 뜸
    
    (JS는 브라우저 안에서만 실행할 수 있는 코드인데, 이렇게 node를 사용하면 터미널에서도 확인 가능한 것)
    
    - node.js 는 프레임워크가 아니라 JS를 실행할 수 있는 환경일 뿐임. (Django는 프레임워크임)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2095.png)
        
        DJango는 MVT라는 패턴이 있으나 
        
        Node.js 에서는 프로그램 전체구조를 개발자가 설계해야함
        
    
    - REPL(=Read Eval Print Loop) 모드
        
        → 사용자가 입력한 내용 읽고, 결과값 계산해서 구한다음, 출력하는 과정을 반복하는것 
        
        → 짧은 코드를 간단하게 테스트할 때 유용
        
        ```jsx
        node
        Welcome to Node.js v16.16.0.      
        Type ".help" for more information.
        >
        
        실행시작
        ```
        
        터미널에서 node 만 입력하면 저렇게 되는데 안에 for 문 console.log 아무거나 쓰게됨
        
        (참고로 3+5 이렇게 치면 8 뜨지만 그냥 함수정의만 하는 식으로 return 값이 없으면 ‘undefined’ 가 뜸)
        
        마치 노드와 대화하는 것처럼 코드를 실행하게 되는데 이것을 REPL 이라함
        
        ```jsx
        .exit
        
        나가짐
        ```
        
    
    ---
    
    # 2. **Node.js 기본개념**
    
    - exports 와 module.exports / require
        
        ```jsx
        <math-tools.js>
        
        function add(a,b){
            return 1;
        }
        //add 함수를 노드 외부에 adds라는 이름으로 공개하겠다
        **exports.plus = add;**
        **(plus 는 모듈 외부로 공개할 이름, add는 모듈 내부에서 이름)**
        
        or
        
        exports.plus= function add(a,b) {return a-b;};
        
        -----------------------------
        
        <main.js>
        
        let m = require('./math-tools.js');
        
        console.log(m.add(1,2));
        ```
        
        ```jsx
        <math-tools.js>
        
        let special = { 
            multiply: (a,b) => a*b,
            divide: (a,b) => a/b,
        };
        
        **module.exports=special;**
        
        -----------------
        
        <main.js>
        
        const m = require('./math-tools');
        
        console.log(m.multiply(1,2));
        console.log(m.divide(1,2));
        
        ```
        
        ```jsx
        let m = require('./math-tools');
        
        console.log(m.plus(1,2));
        console.log(m.minus(1,2));
        console.log(m.multiply(1,2));
        ```
        
        이렇게 모듈을 불러오려면 exports 함수를 이용해서 공개해야하고, require 함수를 이용해서 가져와야한다 (require은 module 객체의 **exports** 속성이 가리키는 객체를 리턴)
        
        1. Node.js 는 모듈을 로드하기 전에 전체코드를 Module wrapper function 으로 감싸준다
        2. 이 함수는 5개인자에 각각 적절한 값이나 객체를 설정해줌. 
        3. exports 인자로 넘어와서 프로퍼티를 하나씩 채워가는 객체 (혹은 module 인자의 exports 속성으로 설정되는 객체) 가 다른모듈에서 이 모듈을 require 함수로 로드했을 때 리턴되는 객체
        
        ```jsx
        (function (exports, require, module, __filename, __dirname) {
        **위에 애들이 Module wrapper function 의 다섯 가지 인자**
        
          function add(a, b) {
            return a + b;
          }
        });
        
        exports.add = add;
        ```
        
        ```jsx
        function add(a, b) {
            return a + b;
          }
          
          exports.plus = add; // add 함수를 plus라는 이름으로 공개
          
          console.log('exports ------------------------->');
          console.dir(exports);
          console.log('require ------------------------->');
          console.dir(require);
          console.log('module ------------------------->');
          console.dir(module);
          console.log('__filename ------------------------->');
          console.dir(__filename);
          console.log('__dirname ------------------------->');
          console.dir(__dirname);
        
        **참고로 console.dir 는 특정 개체의 내부 속성들을 모두 출력해주는 함수**
        
        이를 실행하고 exports 객체와 module 객체 2가지 출력을 보면
        
        exports ------------------------->
        { plus: [Function: add] }
        
        module ------------------------->
        
        Module {
          id: 'C:\\Users\\조성진\\Desktop\\codeit_NODESTUDY\\math-tools.js',
          path: 'C:\\Users\\조성진\\Desktop\\codeit_NODESTUDY',
          exports: { plus: [Function: add] },
          filename: 'C:\\Users\\조성진\\Desktop\\codeit_NODESTUDY\\math-tools.js',
          loaded: false,
          children: [],
          paths: [
            'C:\\Users\\조성진\\Desktop\\codeit_NODESTUDY\\node_modules',
            'C:\\Users\\조성진\\Desktop\\node_modules',
            'C:\\Users\\조성진\\node_modules',
            'C:\\Users\\node_modules',
            'C:\\node_modules'
          ]
        }
        
        exports 객체에 plus라는 프로퍼티가 추가되었고, 프로퍼티의 값이 add 함수인 것을 확인할 수 있습니다. 그리고 module 객체의 exports 프로퍼티가 가리키는 객체도 동일한 객체임을 확인할 수 있음.
        
        exports 는 이렇게 텅 빈 객체를 출력하고 
        module 객체 안에는 다양한 프로퍼티가 있음을 알 수 있다 (여기에 exports 있음)
        
        ---
        
        곧 const m = require('./math-tools');
        
        이렇게 로드하면 module 객체의 exports 프로퍼티를 리턴한다.
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2096.png)
        
        정리하면, Node.js 는 내부적으로 require 함수가 실행될 때 위에서 본 module 객체의 exports 프로퍼티를 리턴한다고 했다.
        
        그러니까 모듈을 로드할 때 Node.js 가 Module wrapper function 의 ‘exports 로 넣어주는 객체’ 와 ‘module 이라는 인자로 넣어주는 객체의 exports 프로퍼티가 가리키는 객체’ 는 위의 이미지처럼 동일한 객체이지만 
        
        ‘require 함수’ 는 module 객체의 exports 프로퍼티가 가리키는 객체를 리턴하기 때문에 exports 객체를 아예 새로 설정해버리면 더 이상 exports 키워드로 원래 객체에 접근할 수 없게됨.
        
        그래서 exports.속성 이런 식으로 객체에 프로퍼티를 추가하게 되며
        
        module.exports 를 사용하면 module.exports + moudule.exports.속성 둘다 쓸 수 있기 때문에 
        
        **exports = 객체 이런식으로 객체 하나를 통째로 리턴하기 보단** 
        
        **exports.속성=값 혹은 module.exports=객체 이렇게 쓴다.**
        
    
    - 모듈이란? 종류 3개
        
        → 전체를 이루는 부품 하나하나(node.js 에서는 JS파일 하나하나를 모듈로 생각)
        
        즉 모듈들이 모여서 하나의 프로그램이 되는 것. 
        
        → 하나의 모듈에서 다른 모듈의 기능을 가져다쓰는 것이 핵심!
        (JS 만들고 
        
        모듈에는 3가지가 있다.
        
        1. 내가 직접 만든 모듈
        2. 이미 만들어져 있는 모듈 - 코어 모듈(노드에 내장)
        3. 이미 만들어져 있는 모듈 - 써드파티모듈(다른 개발자나 회사들이 올려놓은 것)
        
        ```jsx
        //fs가 여러 코어 모듈중 하나임 file system 약자로 파일이나 디렉토리 작업을 할 때 꼭 필요한 모듈
        //디렉토리 생성, 파일 삭제 등의 작업을 코드로할 때 씀
        
        const fs = require('fs');
        
        //특정 디렉토리안에 있는 파일목록들을 배열형식으로 리턴하는 함수
        let fileList = fs.readdirSync('.');
        
        console.log(fileList);
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2097.png)
        
        ```jsx
        
        //new 라는 파일에 Hello Node.js 라는 내용을 쓰는 함수
        //만약 기존에 new 라는 파일이 없으면 파일을 새로 생성하고 내용을 쓰게 됨
        fs.writeFileSync('new','Hello Node.js!');
        
        //컴퓨터에 설치된 운영체제 관련 정보들을 가져오게 됨.
        
        const os = require('os');
        
        //cpus 는 현재 컴퓨터의 cpu 정보를 출력
        console.log(os.cpus());
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2098.png)
        
        코어모듈들은 여기서 확인 https://nodejs.org/dist/latest-v12.x/docs/api/
        
        파일만들어서 내용작성하기, cpu 정보보기 들은 JS로 절대 못하는 작업 (오히려 그런게 있으면 보안상 문제됨)
        
        다만 서버용 프로그램만드려면 그런 기능이 필요하기때문에 node.js 에서는 관련 함수들이 제공됨. 
        
        node.js 활용하면 컴퓨터 깊은 부분까지 JS로 제어할 수 있게 된다
        
    
    - Node.js와 브라우저의 차이 (브라우저나 노드버젼별 JS 표준 구현현황)
        
        node.js 는 자바스크립트 실행환경.
        
        크롬이나 사파리같은 브라우저들도 자바스크립트도 실행한다.
        
        가장 큰차이는 API가 다르다는 점.
        
        API (Application Programmming Interface) 는 어떤 플랫폼이나 실행환경 등에서 제공하는 인터페이스. 
        
        즉, 특정 환경에서 자유롭게 가져다 쓸 수 있는 함수나 객체 등을 의미
        
        node , 브라우저 제공하는 API
        
        둘다 똑같이 JS를 사용하더라도 어느 환경에서 개발하느냐에따라 사용 API가 다름
        
        **node js**
        
        ✅컴퓨터 제어 API가 있다. (파일생성이나 컴퓨터 정보 확인 등)
        
        (이런 특성 때문에 pc용 프로그램 사용하는데도 사용됨. electron 이라는 프레임워크 사용하면 node.js 환경 위에서 작동되는 PC프로그램 제작 가능함. 
        VScode 도 electron 으로 개발된 프로그램임!! VScode 도 node.js 위에서 실행되는 것)
        
        ✅ JS 실행엔진으로 V8 실행
        
        **브라우저**
        
        ✅시각적 표현 필요해서 UI 관련 API 필요하다
        
        ✅ window, documnet 객체 있음
        
        ✅ JS 실행엔진은 V8(크롬) SpiderMonkey(파이어폭스) 엣지(V8,Chakra)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%2099.png)
        
        브라우저를 다루는 프론트엔드를 개발할 때는
        
        특정 브라우저가 JS 표준 문법중에서 어디까지 지원하는지 확인하는게 중요
        
        JS 실행하는 Node 도 마찬가지임.
        
        따라서 node.js 개발 하다가 JS 최신 문법을 쓰고싶다면 사용중인 버젼에 node.js 가 지원하는지 표로 확인
        
        • 각 브라우저별 자바스크립트 표준 구현 현황: [https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/)
        
    
    - 써드파티 모듈 (npm)
        
        다른 개발자나 회사들이 만들어 인터넷에 공개하여 저장하는 모듈
        
        써드 파티 모듈을 공개저장소에서 내 컴퓨터로 가져오자
        
        ```jsx
        npm install cowsay
        
        // npm은 Node Package Manager 로 써드파티모듈 작업을 할 때 필요한 프로그램.
        // 노드를 설치하면 함께 설치가 되었다.
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20100.png)
        
        ```
        //코어모듈처럼 써드파티모듈도 경로없이 이름만 쓰면 로드가능 
        const cowsay = require('cowsay');
        
        //cowsay 모듈에 say라는 함수를 호출했다. say 함수 인자로 text 속성이 IloveJS라는 객체를 준것 
        //cowsay 모듈은 단어가 의미하는 그대로 소가 말하는 그림을 그려주는 재미있는 써드파티모듈임
        console.log(cowsay.say({
            text : "I love javascript",
        }));no
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20101.png)
        
        # 1. package-lock.json
        
        어떤 서드 파티 모듈들이 설치되어있는지 정보가 담겨있다.
        
        하나의 서드파티 모듈이 설치될 때는 그것이 의존하는 다른 서드파티 모듈들이 함께 설치된다.
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20102.png)
        
        package-lock.json 파일을 보면 dependencies 라는 필드에 이렇게 그것이 의존하는 다른 서드퍼티 모듈들이 함께 설치됨!
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20103.png)
        
        cowsay 모듈 → string-width 모듈 → strip-ansi 모듈 → ansi-regex 모듈
        
        이렇게 여러 단계에 걸쳐 ansi-regex 모듈에 의존하는것.
        
        이런 모듈간의 다단계의존관계를 의존하는 것이 중요하다.
        
        # 2. node_modules 디렉토리
        
        서드파티 모듈들이 실제로 설치되는 공간.
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20104.png)
        
        cowsay 서드파티 모듈의 이름이 잘 보이고 그것이 의존하는 다른 서드파티모듈이 잘 보임.
        
        왼쪽 노랑색 강조표시를 보면 모든 서드파티 모듈들은 각각 하나의 디렉토리인걸 아는데
        
        모듈을 이처럼 하나의 파일일 수도 있고 디렉토리일수도있다
        (지금까지는 모듈을 하나의 JS파일이라 배움)
        
    
    Node.js 핵심 개념 2 - 비동기 프로그래밍
    
    - 비동기 프로그래밍 (readFile, readFileSync)
        
        ```jsx
        const fs = require ('fs');
        
        console.log('start');
        
        //파일 내용을 읽어서 리턴하는 함수
        //utf8 은 파일의 내용을 어떤 방식으로 읽을지 지정하는 인코딩임
        **//인코딩이란 컴퓨터에서 1 0 조합봤을때 어떤 문자로 해석해야할지 기준**
        
        //동기적임. 파일 읽기 전까지는 절대 다음코드로 넘어가지 않음
        let content = fs.readFileSync('./new', 'utf8');
        
        //즉 위의 함수보다 얘가 먼저 실행됨 위에 
        console.log(content);
        
        console.log('finish');
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20105.png)
        
        ```jsx
        console.log('start');
        
        //얘넨 비동기적인 함수. 
        //new 파일을 다 읽었을 때 실행되는 3번째 인자(콜백)를 등록해놓음
        //콜백함수는 new 파일 읽기 작업이 완료되면 실행된다
        fs.readFile('./new','utf8',(error,data)=>{console.log(data);});
        
        //그리고 바로 이 함수로 넘어감
        console.log('finish');
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20106.png)
        
        어떤 작업이 완료되었을 때 실행될 함수를 콜백이라함
        
        이렇게 콜백을 등록해두고 다음코드로 실행을 넘기는게 비동기실행
        
        # 1. readFileSync 는 동기 실행함수
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20107.png)
        
        path : 내용을 읽을 파일의 경로
        
        options : 파일의 내용을 읽을 때 적용할 옵션
        
        callback : 파일의 내용을 다 읽었을 때 실행될 콜백
        
        - path, callback 은 필수인자이고 [,options] 같은 선택적인자는 대괄호 안에 쓰여있는데
        
        얘네는 { 'encoding' : 'utf8', 'flag' : 'r' }' 이런 식의 객체(Object)를 넣어도 된다.
        
        - Node.js 에서 err 인자를 첫번째 인자로 두는게 관례. 작업결과를 나타내는 인자는 뒤에 둔다. (err 인자는 error, problem.. dats는 result, output.. 이름으로 써도 코드 실행에는 문제가 없다)
        - 다만 순서 중요!! 앞의 인자에 에러 정보가 담긴 객체가 전달된다!
        
        # 2. readFile 은 비동기 실행함수
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20108.png)
        
        보면 콜백함수 따로 없는 걸 알 수 있음.
        
        fs 코어 모듈안의 함수들은 이렇게 비동기 함수가 있으면 Sync가 붙은 동기함수도 쌍으로 존재하는 경우가 많음!
        
        # 3. 예시
        
        ```jsx
        const fs = require('fs');
        
        let test = 1; // '첫 번째'
        
        fs.readFile('./new', 'utf8', (err, data) => {
          test = 2; // '세 번째'
        });
        
        console.log(test); // '두 번째'
        ```
        
        2 아닌 1이뜸
        
        비동기실행함수이므로 test=1 → readFile 대기 → console.log 에는 1찍힘 → test 변수에 2대입 
        
        # 4. 비동기 실행
        
        빠르다.
        
        프로세스 : 하나의 실행 흐름
        
        스레드 : 더 작은 단위의 실행 흐름
        
        실행이란 
        
        (1) **하드디스크(hard-disk)나 SSD** 에 저장되어 있던 프로그램의 내용을 
        (2) **메모리(memory)** 에 올려서 
        (3) **CPU(Central Processing Unit)** 가 실행하도록 만드는 것을 의미
        
        가령 크롬 브라우저라는 ‘프로그램’ 을 실행하면 하나의 크롬 프로세스라는게 실행되고 하나의 스레드가 실행 중인 상태가 됨
        
        (다운하거나 음악재생하거나 구글검색할 때마다 크롬프로세스 안의 스레드수가 늘어나는것. 강제종료시에는 이 프로세스라는걸 끝내주는것)
        
        메인 스레드가 요청 작업 처리하고 나머지는 여러 개 스레드들에게 맡겨서 걔네 작업이 끝나고 반환한 결과물을 가지고 뭔가를 하게 됨
        
        다시말해 메인스레드는 아래와 같은 작업을 한다.
        
        - CPU로 하는 수치 계산 작업이나
        - 네트워크로 들어오는 클라이언트의 요청을 받아들이고 응답하는 작업
        
        근데 고화질 이미지 처리나 복잡한 수식처리할 때 CPU 를 집중적으로 처리하게 되는데 이런 ************************************CPU intensive job************************************ 은 node.js 에 어울리지 않음. 그만큼 다른 클라이언트들의 요청이 늦게 처리하게 됨. 
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20109.png)
        
        따라서 그럴 땐 Node.js 보다 다른 서버 프레임워크 등을 사용하는게 좋음
        
        그치만 채팅 서버 등은 그런 경우가 없기 때문에 ㄱㅊ
        
    - 비동기 프로그래밍 (이벤트-이벤트를 발생시키는 모든객체는 eventemitter의 객체)
        
        ```jsx
        //EventEmitter 는 클래스
        const **EventEmitter** = require('events');
        const { default: nodeTest } = require('node:test');
        
        //따라서 이렇게 객체를 만들어줘야 사용할 수 있음
        const myEmitter = new EventEmitter();
        
        //이 객체에 두가지 메소드를 호출중
        
        //on 은 콜백을 등록하는 함수! 
        //test 라는 이벤트가 발생했을 때 실행할 콜백을 등록중~~
        //readFile은 읽기 완료하면 바로 실행됐지만 얘는 이벤트가 발생했을 때만 실행 (**test 라는 이벤트**가 발생했을떄 success 출력)
        myEmitter.on('test',()=>{console.log('Success!');});
        
        //얘는 이벤트를 직접 발생시키는 함수!
        //그럼 test 이벤트에 등록되었던 위의 콜백(or listener or eventhandler) 을 실행시킬 것이다
        myEmitter.emit('test');
        
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20110.png)
        
        ```jsx
        const EventEmitter = require('events');
        
        const myEmitter = new EventEmitter();
        const myEmitter2 = new EventEmitter();
        
        myEmitter.on('test',()=>{console.log('Success! 1');});
        
        myEmitter.on('test',()=>{console.log('Success! 2');});
        
        myEmitter2.on('test',()=>{console.log('Success! 3');});
        
        myEmitter.emit('test');
        ```
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20111.png)
        
        이렇게 여러가지 콜백도 등록가능
        
        단, 이벤트 발생시키고 실행되는 연산은 하나의 이벤트 객체 내에서만!!
        
        (이벤트 설정과 콜백실행은 하나의 EventEmitter 객체 안에서만 이루어짐. 아무리 이벤트 이름이 test 로 같아도 서로 반응성없음)
        
        코어 모듈에서 가져다쓸 다양한 함수들이 이벤트 기반으로 작성되어있음!
        
        (**콜백은 listener 혹은 eventhandler 라고도 함)**
        
        “Node.js에서 이벤트 기반 프로그래밍을 하려면 events라는 코어 모듈의  event 클래스로 객체를 만들어서 사용해야 합니다. 그리고 코어 모듈에 있는 많은 객체들도 결국 Eventemitter 객체일 때가 많기 때문에 EventEmitter 객체의 사용법을 잘 알아야한다”
        
        - **“이벤트를 발생시키는 모든 객체는 결국 eventemitter 의 객체”**
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20112.png)
            
            net 이라는 코어모듈 안의 클래스!
            
            **Extends:<EventEmitter> 이말은**
            
            EventEmitter 를 상속하게 되는데 net.Server 클래스가 EventEmitter 클래스에 있는 기능들을 물려받아 쓴다는 얘기
            
            **net.Server is an EventEmitter with the following events 이말은**
            
            net.Server 객체도 EventEmitter 객체고 아래의 Close, connection… 등의 이벤트에 대한 콜백을 등록할 수 있다는 뜻
            
            “이처럼 코어모듈의 많은 객체들이 event emitter 객체당”
            
        - **EventEmitter 객체의 다른 메소드는?**
            1. **on**
            
            ```jsx
            myEmitter.on('test', () => { console.log('Success!'); });
            
            myEmitter.emit('test');
            ```
            
            이벤트 헨들러를 설정하는 메소드
            
            1. **addListner**
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20113.png)
            
            보통 짧은 on 을 쓰지만 addListner 라고 쓸 수도 있음. 
            
            1. **emit**
            
            emit 메소드는 인위적으로 이벤트를 발생시키기 위해 쓰는 메소드. 
            
            다만 나만의 독특한 EventEmitter 객체를 만들지 않는 이상 사용할 일이 많지 않다.
            
            (이미 코어모듈에 존재하는 EventEmitter 객체를 사용하는 경우가 더 많기 때문)
            
            - 파일의 내용을 읽을 때, 데이터를 읽어들일 때마다 발생하는 이벤트
            - 외부로부터의 클라이언트 요청이 발생했을 때 발생하는 이벤트 등
            
            이것들은 직접 emit 메소드로 발생시키는게 아니라 해당이벤트가 발생했을 때 Node가 발생시켜주는것.
            
            그래도 emit 과 on은 한 쌍을 이루게 되니 잘 기억하기
            
            1. **once**
            
            on과 유사하지만 해당 이벤트에 대해서 딱 한 번만 반응해서 실행됨
            
            ```jsx
            myEmitter.once('test', () => { console.log('Success!');} );
            
            myEmitter.emit('test');
            myEmitter.emit('test');
            myEmitter.emit('test');
            ```
            
            즉 특정이벤트가 한 번 밖에 발생하지 않거나 딱 한 번만 실행되기 바라는경우 이 메소드를 사용
            
            1. l**istners**
            
            ```jsx
            myEmitter.once('test', () => {
              console.log('A');
            });
            
            myEmitter.once('test', () => {
              console.log('B');
            });
            
            myEmitter.once('test', () => {
              console.log('C');
            });
            
            console.log(myEmitter.listeners('test'));
            ```
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20114.png)
            
            listners 는 특정 이벤트에 대한 이벤트 헨들러들을 출력해주는 메소드임
            
            위와 같이 하나의 이벤트에 관해 여러개의 이벤트 헨들러들을 설정할 수 있는데
            
            코드를 작성하다가 특정 이벤트에 어떤 이벤트들이 설정되어있는지 조회하고 싶은데 코드를 처음부터 다시보기 어려우면 이 메소드를 쓴다
            
            1. **off**
            
            이벤트 핸들러를 설정하는것이 on 이라면 이벤트 핸들러를 해제하는게 off
            
            off 메소드를 쓸 땐 해제할 이벤트 핸들러를 정확히 지정해줘야된다.
            
            ```jsx
            const EventEmitter = require('events');
            
            const myEmitter = new EventEmitter();
            
            myEmitter.on('test', () => { // --- (A)
              console.log('Success!');
            });
            
            myEmitter.off('test', () => { // --- (B)
              console.log('Success!');
            });
            
            myEmitter.emit('test');
            ```
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20115.png)
            
            off 썼는데도 반응한다. 이유는 이벤트헨들러 (A)와 (B)가 똑같이 생겼지만 서로 다른함수라서
            
            ```jsx
            const EventEmitter = require('events');
            
            const myEmitter = new EventEmitter();
            
            const callback = () => {
              console.log('Success!');
            };
            
            myEmitter.on('test', callback);
            
            myEmitter.off('test', callback);
            
            myEmitter.emit('test');
            ```
            
            이러면 비로소 아무것도 안뜨게됨
            
            이렇게 이벤트에 반응하지 않는다는 걸 알 수 있습니다. 이벤트 핸들러가 잘 해제된 거죠. off 메소드를 사용할 때는 설정했던 이벤트 핸들러를 정확하게 off하고 있는 게 맞는 건지 꼭 확인하세요.
            
            ```jsx
            const EventEmitter = require('events');
            
            const myEmitter = new EventEmitter();
            
            const cbArr = [];
            
            cbArr[0] = () => {
              console.log('A');
            };
            
            cbArr[1] = () => {
              console.log('B');
            };
            
            myEmitter.on('test', cbArr[0]);
            myEmitter.on('test', cbArr[1]);
            
            myEmitter.off('test', cbArr[0]);
            myEmitter.off('test', cbArr[1]);
            
            myEmitter.emit('test');
            ```
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20116.png)
            
            이벤트 핸들러를 나중에 off 메소드에서도 참조할 수 있도록 변수에 할당해주거나, 여러 개의 이벤트 핸들러인 경우 이렇게 배열에 넣어서 관리해줘야 합니다.
            
            ---
            
            추가 메소드는 여기참고
            
            [https://nodejs.org/api/events.html#events_class_eventemitter](https://nodejs.org/api/events.html#events_class_eventemitter)
            
        - **이벤트에 추가정보 함께 전달하기**
            
            ```jsx
            const EventEmitter = require('events');
            
            const myEmitter = new EventEmitter();
            
            myEmitter.on('test', (arg1,arg2,arg3) => {
            	console.log(arg1);
            	console.log(arg2);
            });
            
            myEmitter.emit('test','apple','banana','pear');
            ```
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20117.png)
            
            apple banana 까지 뜨는걸 확인할 수 있음.
            
            ```jsx
            const EventEmitter = require('events');
            
            const myEmitter = new EventEmitter();
            
            myEmitter.on('test', (arg1,arg2,arg3,arg4) => {
            	console.log(arg1);
            	console.log(arg2);
                console.log(arg3);
                console.log(arg4);
            });
            
            myEmitter.emit('test','apple','banana','pear');
            ```
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20118.png)
            
            만약 arg가 더 많다면 undifined 가 뜬다
            
            ```jsx
            const EventEmitter = require('events');
            
            const myEmitter = new EventEmitter();
            
            const obj = {type:'text', data: 'Hello CodeIt', date: '2020-09-01'};
            
            myEmitter.on('test',(info)=>{console.log(info);});
            
            myEmitter.emit('test',obj);
            ```
            
            ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20119.png)
            
            이렇게 obj 객체를 만들어서 쏠 수도 있네.
            
            info 를 쏘네
            
        
    - 비동기함수의 콜백이 실행되는 원리
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20120.png)
        
        이벤트 루프란 각종 콜백들의 실행조건(특정 시간이 경과했는지 등)을 확인하고 실제로 실행하는 로직이다. 특정 콜백의 **실행조건이 만족된 것을 확인하면** **queue** (자료구조의 큐 처럼 구현된 저장소. 여기선 콜백들이 저장되는 저장소) **라는 곳에 콜백을 삽입**한다.
        
        위의 코드를 실행하면 node는 
        
        1. 하나의 스레드로 자바스크립트 코드를 차례대로 실행하고
        2. 그 스레드는 그후에 event loop 을 돌게 되는데 이 때 각각 콜백들에 대한 실행여부를 판단하고 Queue 에 넣은 후 Queue에 담긴 콜백들을 실행한다.
        
        (콜백이 여러개 일때는 각 콜백의 실행조건이 충족될때 차례대로 queue에 들어가게 되고
        
        콜백들은 queue 에 들어간 순서대로 Event loop 에 의해 실행된다.)
        
        ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20121.png)
        
        이렇게 하면 하나의스레드로 쭉 코드를 실행하고 콜백을 등록만해둔다.
        
        그렇게 코드를 다 실행한후 Event loop 을 돌면서 Queue에 담을 것을 보는데,
        
        하늘색 콜백은 0초후 실행되는거니까 바로 Queue에 담는다.
        
        그리고 콜백을 실행하니 변수에 num=2 를 담는다. 
        
        (같은 논리로 3초를 두었을 때 Queue 에 실행될 콜백이 밀려있다면 3초보다 늦게 실행될 수도 있다. 단 3초보다 먼저 실행되지는 않는다)
        
        (같은 논리로 마지막에 while (true) { } 를 쓰면 코드가 안끝나기 때문에 콜백은 실행이 안됨)
        
    
    ---
    
    # 3. 초간단 웹서버 만들기
    
    ---
    
    # 4. 서드파티모듈과 npm
    
    npm은 써드파티모듈을 다룰 때 사용한다.
    
    ```jsx
    npm install cowsay
    npm install express
    ```
    
    여기서 cosway, express 가 모듈이름.
    
    써드파티모듈을 설치하면 작업하던 디렉토리 안에 새로운 것들이 생긴다.
    (package-lock.json, node_modules)
    
    *node_modules 안에는 써드파티 모듈들이 있다.
    
    *cowsay 나 express 설치할 때 그것들이 필요로 하는 여러가지 써드파티모듈들이 함께 설치된 것 (이렇게 하나의 써드파티모듈은 다른 써드파티모듈을 필요로하는데 이런 모듈을 영어로 **dependencies** 라고 한다)
    
     
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20122.png)
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20123.png)
    
    설치된 것은 파일이름이 아니라 디렉토리로 표시됨
    
    모듈은 하나의 자바스크립트 파일이 맞지만?
    
    모듈의 이름은 파일(A.js) 일수도 있고 디렉토리(A) 일수도 있다.
    
    require 할 때 이런절차를 따른다
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20124.png)
    
    경로표시가 있을 때,
    
    경로파일이 있다면 해당 파일을 로드하고 파일이 아닌 디렉토리가 있다면 디렉토리 안에 package.json 파일을 찾아 해당 main 필드에 적힌 파일 로드하고
    
    package.json 파일이 없다면 디렉토리안에 inde.js 파일을 로드함
    
    **경로표시가 없을 때,**
    
    해당이름의 **코어모듈이 있으면 로드**하고 해당 모듈이 **없으면 써드파티모듈이라고 생각**하고 **node_modules 디렉토리** 안에 그런 파일이 있는지 뒤져보고 **그것을 로드**하거나 
    
    node_moudles 디렉토리 내에 그런 디렉토리가 없으면 그 안의 디렉토리를 찾고 **package.json 찾고 그 main 필드**에 적힌 파일을 로드하거나
    
    pacakge.json 없으면 디렉토리안 **index.js** 파일로드하는것
    
    즉 써드 파티 모듈은 항상 경로표시가 없을 때 → 해당이름의 코어모듈이 없을 때의 과정을 따름
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20125.png)
    
    **“써드 파티모듈은 pacakage.json 이라는 파일을 가진 디렉토리로 존재한다”**
    
    **그래서 써드파티모듈의 이름이 디렉토리 이름과 같았던것**
    
    ![이렇게 써드파티모듈 하나에는 package.json 파일이 담김](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20126.png)
    
    이렇게 써드파티모듈 하나에는 package.json 파일이 담김
    
    **package.json 이라는 파일을 가진 디렉토리를 ‘패키지’ 라고 한다.**
    
    **곧 하나의 써드파티모듈은 하나의 패키지이다! (써드파티모듈=패키지)**
    
    ```jsx
    npm install express
    
    // 이런식으로 패키지 설치함
    ```
    
    **npm 이 Node package manager 로 노드 위에서 동작하는 패키지매니저라는 뜻**
    
    ( 여기 등장하는 패키지가 위의 패키지. 써드파티모듈을 설치하고 관리하는 프로그램이 npm인데 결국 모든 써드파티모듈은 패키지이기 때문에 이런 이름이 붙은 것)
    
    ---
    
    한편,  package.json 파일은 해당 패키지에 관한 정보를 갖고 있는 파일
    
    ![Untitled](%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%B5%209ab67a7d2b004316b9ddb43770cc773d/Untitled%20127.png)
    
    읽어보면 제작자 등이 나와있는 필드도 있고
    
    “engines’ 필드에서는 이 패키지들이 잘 동작하기위한 노드의 버전도 있고
    
    “dependencies” 들도 있음 (node.js 패키지 생태계에서 아주중요한 필드)
    
    - Semantic Version
        
        디펜던시들 옆에 붙은 것을 Semantic Version 이라고 하는데 ‘의미론적 버젼’ 이란 뜻
        
        API (Application Programming Interface)  변화 기준으로 버젼을 업데이트해야된다.
        
        X.Y.Z 에서 
        X는 이전 API와 호환되지 않을 때임 (고로 이것이 바뀌었다면 이전 버젼 패키지에서 어떤 부분들이 바뀐건지 체크하고 코드 재수정해야함.)
        
        <aside>
        👉 하위 호환성을 유지하지 못하는(not backward-compatible) API 상의 변화가 일어났다면, 반드시 Major version을 업데이트해줘야 합니다.
        
        하위 호환성을 유지하지 못한다는 것은 쉽게 말해,
        
        - 업데이트 전의 패키지를 사용하던 패키지 즉, 해당 패키지에 의존하던 다른 패키지에서
        - 만약 업데이트된 버전을 그대로 사용할 경우,
        - 기존 API의 이름 변경/삭제 등으로 인해 그 패키지가 정상적으로 작동할 수 없다는 것 (추가는 x)
        </aside>
        
        Y는 이전 API와 호환되는 API 변화가 발생했을 때 업데이트
        
        Z는 API에 변화를 주지 않는 범위내에서 변화가 이루어진경우(코드 버그 해결이나 알고리즘을 바꿔서 효율성 향상 시킨 경우 등)
        
    - Version Range Syntax
        
        # **1. Semantic Version이란?**
        
        이전 노트에서 본 express 패키지의 package.json 파일의 dependencies 필드를 살펴봅시다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3736&directory=Untitled.png&name=Untitled.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3736&directory=Untitled.png&name=Untitled.png)
        
        여기서 각 패키지의 이름 옆에 적힌 버전에 대한 이야기를 해보겠습니다. 
        dependencies 필드에 있는 각 패키지 이름 옆의 버전은 **Semantic Version**이라고 하는데요. Semantic Version을 우리말로 해석하면 '의미론적 버전' 정도로 해석할 수 있습니다.
        
        Semantic Version은 위 그림에서 보이는 것처럼 1.3.7, 6.7.0 등과 같이 총 세 개의 숫자로 이루어진 버전인데요. 이때 이것을
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3736&directory=Untitled%201.png&name=Untitled+1.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3736&directory=Untitled%201.png&name=Untitled+1.png)
        
        이 이미지처럼 쪼개봤을 때,
        
        **X를 메이저 버전(major version)Y를 마이너 버전(minor version)Z를 패치 버전(patch version)**
        
        이라고 합니다. Semantic Version에서 중요한 것은 패키지의 버전을 업데이트할 때 일정한 규칙이 있다는 점인데요.
        
        이 규칙을 배우기 전에 먼저 API라는 것이 뭔지 간단히 알아야합니다. API란 Application Programming Interface의 약자로 '외부에서 사용할 수 있도록 공개된 함수'를 의미합니다. 우리가 코드 내에서 require 함수를 써서 어떤 패키지를 로드하는 이유는 뭔가요? 그 패키지가 공개하는 함수 등을 사용하기 위해서잖아요? 이렇게 외부에서 사용할 수 있도록 공개된 함수 등을 모두 API라고 하는 겁니다. Semantic Version에서는 이 API의 변화를 기준으로 버전을 업데이트해야 합니다. 하나씩 설명해볼게요.
        
        **첫 번째로 가장 오른쪽의 패치 버전은, API에 변화를 주지 않는 범위 내에서의 변화가 이루어진 경우에 업데이트합니다.** 이런 경우는 어떤 것들이 있을까요? 겉으로 공개된 API는 바뀌지 않았지만, 코드에 존재하던 버그를 해결하거나, 알고리즘을 바꿔서 그 효율성을 향상시킨 경우 등이 해당하겠죠? 이럴 때는 예를 들어, 버전을 2.3.1에서 2.3.2로 올릴 수 있는 겁니다. 2.3.1에서 바로 2.4.0이나 3.0.0으로 업데이트하면 안 되는 것이고요.
        
        **두 번째로 가운데에 있는 마이너 버전은, 이전 버전의 API와 호환되는(backward-compatible) API 상의 변화가 발생했을 때 업데이트합니다.** 예를 들어, 새로운 API를 추가한 경우를 생각해봅시다. 그러니까 2.3.1 버전에서 새로운 API를 추가하면 2.4.0으로 버전을 올리면 됩니다. 그럼 기존의 2.3.1 버전의 패키지를 믿고 사용했던 다른 곳에서 이 패키지의 2.4.0 버전을 사용해도 괜찮은 걸까요? 네, 괜찮습니다. 왜냐하면 API 상의 변화가 생기긴 했지만 이미 존재했던 API들은 건드리지 않는 범위의 변화(단순 API 추가)가 발생한 것이기 때문입니다.
        
        **마지막으로 가장 왼쪽의 메이저 버전은, 이전 버전의 API와 호환되지 않는(not backward-compatible) API 상의 변화가 발생했을 때 업데이트합니다.** 기존의 API를 아예 삭제했거나 그 이름을 바꾸는 등의 변화가 이것에 해당하는데요. 이럴 때는 원래 2.3.1 버전이었다면 3.0.0으로 버전을 올려줘야 합니다. 만약 자신이 사용하던 패키지의 메이저 버전이 업데이트되었다면 그리 좋은 소식은 아닐 수도 있습니다. 왜냐하면 그 패키지의 최신 버전을 사용하고 싶다면, 원래 사용하던 이전 버전 패키지의 API에서 어떤 부분들이 바뀐 건지를 체크하고, 코드를 재수정해야 할 가능성이 높기 때문입니다.
        
        그리고 메이저 버전 업데이트는 패키지를 만드는 사람 입장에서도 너무 자주 해서는 안 되는 작업이기도 합니다. 특히, 인기가 많은 패키지일수록 해당 패키지에 의존해서 만들어진 것들이 많을 텐데 만약 메이저 버전 업데이트가 자주 발생하면 이것에 대해 많은 사람의 수고가 필요하기 때문이죠. 하지만 그렇다고 메이저 버전 업데이트를 안 할 수는 없는 일이겠죠? 만약 메이저 버전 업데이트가 발생했다면 해당 업데이트를 한 사람은 그 패키지를 가져다 쓴 사람들이 잘 알 수 있도록 홈페이지에 잘 공지해두고, 어떤 점이 크게 바뀐 건지를 잘 정리해두는 게 좋습니다.
        
        Semantic Version이 뭔지 이해가 되시나요? 생각보다 엄격한 규칙이 포함된 버전 표기법이죠? 이런 체계적인 버전 관리 규칙이 있기 때문에 Node.js의 패키지 생태계가 잘 유지될 수 있는 겁니다.
        
        # **2. Version Range Syntax 배우기**
        
        이번에는 방금 배운 Semantic Version을 기반으로 패키지가 다른 패키지의 어느 버전들을 요구하는지를 나타낼 때 사용되는 **Version Range Syntax(버전 범위에 관한 표기법)**에 대해 배워보겠습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3736&directory=Untitled.png&name=Untitled.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3736&directory=Untitled.png&name=Untitled.png)
        
        지금 이 이미지를 다시 보면 Semantic Version만 쓰여 있는 경우도 있지만 Semantic Version 왼쪽에 물결 모양 기호가 붙어있는 것도 보입니다. 물결 모양 기호의 정식 명칭은 틸드(Tilde)인데요. 이것도 Version Range Syntax 중의 하나입니다.
        
        자, 이제
        
        - codeit이라는 패키지가 존재하고,
        - express 패키지가 codeit 패키지를 필요로 한다고 가정한 후,
        
        Version Range Syntax를 본격적으로 배워봅시다.
        
        ## **(1) Basic Syntax**
        
        - "codeit" : "2.3.1"
        
        이렇게 쓰여 있으면 정확히 2.3.1 버전의 codeit 패키지가 필요하다는 뜻입니다.
        
        - "codeit" : ">2.3.1"
        
        2.3.1보다 높은 버전의 codeit 패키지가 필요하다는 뜻입니다.
        
        - "codeit" : "2.3.1 || ≥2.5.0 <3.1.2"
        
        2.3.1 버전의 codeit 패키지 또는 2.5.0 버전 이상이면서 3.1.2 버전 미만의 codeit 패키지가 필요하다는 뜻입니다. **||(or)**는 왼쪽 조건과 오른쪽 조건 중 하나를 만족해야 한다는 뜻이고, ≥2.5.0 <3.1.2 사이의 **공백** 하나는 왼쪽과 오른쪽 조건 **둘 다(&, and)**를 만족해야 한다는 뜻입니다.
        
        여기까지는 별로 어렵지 않죠? 이제 좀더 응용된 형태의 Syntax들도 보겠습니다.
        
        ## **(2) Advanced Syntax**
        
        ### **1) Hyphen Range**
        
        - "codeit" : "2.3.1 - 3.1.2"
        
        2.3.1 버전 이상 3.1.2 버전 이하의 codeit 패키지가 필요하다는 뜻입니다. 이것은 ≥2.3.1 ≤3.1.2 을 줄여서 표시한 것이라고 생각하면 됩니다. 이때 패치 버전이나 마이너 버전을 표시하지 않는 경우도 있을 수 있는데요.
        
        예를 들어, 2.3 - 3.1.2이면 자동으로 ≥2.3.0 ≤3.1.2 으로 빈자리에 0이 붙어서 해석됩니다. 
        하지만 만약 그런 버전이 오른쪽에 있다면,
        
        그러니까 예를 들어 2.3.1 - 3.1 이면 ≥2.3.1 <3.2.0 이렇게 다르게 해석됩니다.  
        같은 원리로 2.3.1 - 3 이면 ≥2.3.1 <4.0.0 이렇게 해석됩니다.
        
        ### **2) X-range**
        
        - "codeit" : "*"
        
        어느 버전의 codeit 패키지도 상관없다는 뜻입니다.
        
        - "codeit" : "3.x"
        
        x에는 어떤 버전이 들어가도 상관없다는 뜻입니다. 즉, ≥3.0.0 <4.0.0 과 같은 뜻입니다. 
        참고로 그냥 3이라고만 써있어도 3.x로 해석이 되어서 ≥3.0.0 <4.0.0 라는 뜻입니다.
        
        - "codeit" : "3.1.x"
        
        같은 원리로 ≥3.1.0 <3.2.0 라는 뜻입니다. 
        참고로 그냥 3.1이라고만 써있어도 3.1.x로 해석이 되어서 ≥3.1.0 <3.2.0 라는 뜻입니다.
        
        ### **3) Tilde Range**
        
        위에서 봤던 물결 모양 기호(~, Tilde, 틸드)를 사용한 표기법인데요. 이 경우에는 마이너 버전이 표시된 경우는 패치 버전 업데이트까지만 허용하고, 마이너 버전이 없으면 마이너 버전의 업데이트까지 허락하는 겁니다.
        
        - "codeit" : "~3.1.2"
        
        이런 경우는 ≥3.1.2 <3.2.0 이렇게 해석이 됩니다. 지금 3.1.2에 마이너 버전이 존재하므로 패치 버전이 업데이트된 것들만 허용합니다.
        
        - "codeit" : "~3.1"
        
        만약 이렇게 패치 버전이 적혀있지 않다면 ≥3.1.0 <3.2.0 이렇게 해석됩니다. 지금 3.1에 마이너 버전이 존재하므로 패치 버전이 업데이트된 것들만 허용되는 겁니다. 생략된 패치 버전은 0부터 시작합니다.
        
        - "codeit" : "~3"
        
        만약 마이너 버전도 적혀있지 않다면 ≥3.0.0 <4.0.0 이렇게 해석됩니다. 즉, 마이너 버전이나 패치 버전이 업데이트된 버전들만 허용합니다.
        
        ### **4) Caret Range**
        
        메이저 버전, 마이너 버전, 패치 버전 중에서 현재 보이는 가장 왼쪽의 0이 아닌 버전이 바뀌지 않는 선에서의 버전 업데이트만을 허용합니다.
        
        - "codeit" : "^1.2.3"
        
        가장 왼쪽의 0이 아닌 버전, 즉, 1이 바뀌지 않는 선에서의 버전 업데이트만 허용됩니다. 여기서는 ≥1.2.3 <2.0.0 이라는 뜻입니다.
        
        - "codeit" : "^0.2.3"
        
        가장 왼쪽의 0이 아닌 버전, 2가 바뀌지 않는 선에서의 버전 업데이트만 허용됩니다. ≥0.2.3 <0.3.0 이라는 뜻입니다.
        
        - "codeit" : "^0.0.3"
        
        가장 왼쪽의 0이 아닌 버전, 3이 바뀌지 않는 선에서의 버전 업데이트만 허용됩니다. ≥0.0.3 <0.0.4 이라는 뜻입니다.
        
        Version Range Syntax에 대해 배워봤는데요. 별로 어렵지는 않죠? 마지막의 Tilde Range와 Caret Range만 잘 구별할 수 있다면 큰 어려움은 없을 겁니다. 
        
        자, 이때까지
        
        > 한 패키지의 package.json 파일에 있는 
        dependencies 필드에 적힌 
        각각의 패키지 이름 옆에 붙은 Semantic Version과 Version Range Syntax에 대해 배웠습니다.
        > 
        
        이 두 가지를 잘 이해하면 앞으로 패키지 간의 의존 관계를 쉽게 해석할 수 있게 될 겁니다.
        
    
    - **pacakage.json 안의 필드들**
        
        패키지 안에 있는 **package.json** 파일에는 해당 패키지에 관한 의미있는 정보들이 담겨있습니다.
        이번 노트에서는 package.json에 등장할 수 있는 주요 필드들에 대해서 설명해드리겠습니다. 하나하나 꼼꼼하게 읽어보세요.
        
        # **1. name**
        
        패키지의 이름입니다. 우리가 특정 패키지를 사용하기 위해 코드에서 require 함수의 인자로 넣는 것이 바로 여기에 적힌 이름입니다.
        
        # **2. version**
        
        패키지의 버전입니다. 하나의 패키지는 그 안의 코드 등이 개선될수록 버전이 업데이트되는데요. 바로 위의 name 필드와 이 version 필드를 결합하면 **특정 패키지**의 **특정 버전**을 나타낼 수 있습니다.
        
        # **3. description**
        
        패키지에 대한 설명입니다. 패키지를 검색할 때 여기 있는 내용도 검색 기준으로 활용되기 때문에 자신의 패키지가 잘 검색되도록 하려면 여기에 알맞은 설명을 써두는 게 좋습니다.
        
        # **4. keywords**
        
        패키지에 대한 키워드들입니다. 우리가 SNS에서 이미지를 올릴 때 함께 적는 해시태그 같은 거라고 생각하시면 됩니다. keywords도 description처럼 검색 기준으로 활용되기 때문에 적절한 키워드들을 써주면 좋습니다.
        
        # **5. homepage**
        
        패키지 관련 사이트의 URL입니다. 패키지 관련 커뮤니티의 홈페이지 주소가 있는 경우가 많습니다.
        
        # **6. bugs**
        
        패키지를 사용하다가 발생하는 버그들을 신고할 수 있는 URL이나 이메일 주소가 적혀있습니다. 여러분도 패키지를 사용하다가 이상한 점이 있다면 이 필드를 보고 신고하면 좋겠죠?
        
        # **7. license**
        
        패키지의 라이센스 정보가 담겨있습니다. 패키지가 가질 수 있는 라이센스의 종류에 대해 알고 싶다면 [이 링크](https://spdx.org/licenses/)를 참조하세요.
        
        # **8. author, contributors**
        
        author는 패키지를 만든 사람, contributors는 패키지를 만드는데 기여하는 사람들입니다. 이 모두가 모여 패키지를 점점 더 개선해나가는 것입니다.
        
        # **9. main**
        
        이 패키지를
        
        ```
        require('패키지 이름')
        
        ```
        
        로 로드했을 때 실제로 로드되는 파일의 이름이 적혀있는 필드입니다. [이전 영상](https://www.codeit.kr/learn/3732)에서 require 함수가 모듈을 로드하는 절차를 설명할 때 이야기했던 필드인데요.
        
        예를 들어, A라는 패키지가 있고, A 패키지의 package.json 파일의 내용 중, main 필드에 start.js라는 값이 적혀있다고 합시다.
        
        > 그럼 해당 프로젝트에 있는 다른 어떤 자바스크립트 파일 안에서 require('A') 코드는 결국 start.js 파일을 로드한다는 뜻이고,
        이 start.js 파일 내의 코드에서 exports, module.exports 등으로 외부에 공개한 객체를 가져오게 되는 겁니다. 대부분의 패키지가 이런 방식으로 사용되기 때문에 보통 package.json 파일에는 main 필드가 존재합니다. 만약 main 필드가 없다면, 이전 영상에서 배운 것처럼 작업 디렉토리 안에서 index.js라는 파일을 찾아서 로드합니다.
        > 
        
        main 필드는 꼭 정확하게 기억해두세요!
        
        # **10. man**
        
        이 패키지의 사용 설명서가 담긴 파일들의 경로가 적혀있습니다.
        
        # **11. repository**
        
        이 패키지의 코드가 관리되고 있는 레포지토리(repository)의 주소를 나타냅니다. 보통 버전 관리 시스템의 저장소 URL(GitHub URL 등)이 여기 적혀있습니다. 레포지토리가 정확히 무엇인지 알고 싶은 분들은 [코드잇의 'Git' 토픽에서 이 영상](https://www.codeit.kr/learn/courses/version-control-with-git/2885)을 참고하세요.
        
        # **12. scripts**
        
        여기에는 npm으로 간편하게 실행할 수 있는 스크립트 파일들의 정보가 담겨있습니다. 만약 이 필드에
        
        ```
        "scripts" : {
          "test" : "실행할 커맨드 A"
        }
        
        ```
        
        이런 식으로 적혀있으면 터미널에서
        
        ```
        npm run test
        
        ```
        
        라고 쓰고 실행했을 때 '실행할 커맨드 A'가 실행됩니다.
        
        예를 들어, sample.js라는 파일에
        
        ```
        console.log('Test Completed!');
        
        ```
        
        라고 쓰고 저장한 다음, scripts 필드에는
        
        ```
        "scripts" : {
          "test" : "node sample.js"
        }
        
        ```
        
        라고 쓰고 저장하면
        
        터미널에서 **npm run test**라고 쓰고 실행했을 때,
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3735&directory=Untitled.png&name=Untitled.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3735&directory=Untitled.png&name=Untitled.png)
        
        'node sample.js'가 실행되고 그 결과가 잘 출력됩니다.
        
        잠깐 express 패키지의 package.json 파일의 scripts 필드를 예시로 보면
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3735&directory=Untitled%201.png&name=Untitled+1.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3735&directory=Untitled%201.png&name=Untitled+1.png)
        
        이렇게 다양한 단어들이 보이는데요. 대부분 코드 테스트에 관한 커맨드인 것 같죠? 이렇게 scripts 필드는 특히 길이가 긴 명령어를 즐겨찾기해두고 좀 더 편하게 호출하기 위해 사용하는 필드입니다. 나중에 npm을 능숙하게 다루게 됐을 때 자주 찾아보게 될 필드니까 잘 기억해두세요.
        
        scripts 필드에 대해 더 자세히 알고 싶은 분은 [이 링크](https://docs.npmjs.com/misc/scripts)를 참조하세요.
        
        # **13. dependencies**
        
        현재 패키지가 의존하고 있는 다른 패키지들이 나열되어 있는 필드입니다. 이전 영상에서 제가 강조했던 필드죠? 이 필드는 **Node.js 패키지 생태계의 핵심이 되는 필드**라고 했습니다. 왜냐하면 어떤 패키지를 설치할 때 결국, 이 필드가 있어야, 필요한 하위 패키지들을 설치할 수 있기 때문입니다. 잠깐 express 패키지의 dependencies를 볼까요?
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3735&directory=Untitled%202.png&name=Untitled+2.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3735&directory=Untitled%202.png&name=Untitled+2.png)
        
        express 모듈 하나도 정말 많은 모듈에 의존하고 있네요. 그리고 자세히보면, 각 dependency의 정보로는,
        
        - 왼쪽에 모듈의 이름, 오른쪽에 모듈의 버전 정보
        
        가 적혀있습니다. 
        버전 정보의 경우 빨간 박스 안을 보면
        
        > 총 세 개의 숫자로 이루어져 있고 
        맨 앞에 물결 모양 표기가 있는 것도 있는데요.
        > 
        
        버전 정보에 대한 이야기는 다음 노트에서 하겠습니다.
        
        자, 이때까지 package.json 파일의 각 필드에 대해서 살펴봤습니다. package.json 파일은 꽤 중요한 파일이기 때문에 각 필드의 기본적인 의미를 기억해둬야 합니다. package.json 파일에 등장하는 모든 필드에 대해서 알고 싶다면 [공식 문서의 내용](https://docs.npmjs.com/files/package.json)을 참고하세요.
        
    
    - 내 모듈을 패키지로 만드는법
        
        
        패키지란 package.json 파일을 갖고 있는 디렉토리 이므로 내가 만든 프로젝트에 package.json 파일을 만들면 패키지가 된다.
        
        파일내용을 일정한 형식에 맞춰서 작성해야하는데 
        
         
        
        ```jsx
        npm init
        
        //현재 디렉토리를 하나의 패키지로 만들겠다
        ```
        
        package name, version, description 쓰면되고 
        entry point 란 진입점. 다른 패키지에서 내가 만들 패키지를 로드할 때 '실제로 로드될' 파일. main.js가 디폴트
        test command, git repository
        keywords 는 패키지를 npm의 공개저장소에 업로드했을 때 검색기준으로 쓸 것
        등등 입력하면 Is this OK? 나오면 yes 누르면 된다
        
        dependencies 가 자동으로 채워지게 되는데 npm이 내 디렉토리를 분석해서 자동으로 채워주고 있는 것임.
        
        끝나면 package.json 파일이 생긴다.
        
    - 내 패키지를 npm 공개 저장소에 올려보기
        
        # **1. npm 회원가입**
        
        1> 먼저 [npm 공식 홈페이지](https://www.npmjs.com/)에서 화면 우측 상단의 Sign up 버튼을 누르세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled.png&name=Untitled.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled.png&name=Untitled.png)
        
        2> 그다음 사용할 사용자 이름(Username)과 이메일 주소, 비밀번호를 입력한 후, '약관 동의' 버튼에 체크하고, Create an Account 버튼을 클릭하세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%201.png&name=Untitled+1.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%201.png&name=Untitled+1.png)
        
        3> 회원 가입을 마쳤으면, Sign in 버튼을 클릭해서 로그인하세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%202.png&name=Untitled+2.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%202.png&name=Untitled+2.png)
        
        4> 사용자 이름과 비밀번호를 입력하고 Sign In 버튼을 클릭하세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%203.png&name=Untitled+3.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%203.png&name=Untitled+3.png)
        
        5> 그럼 이렇게 화려한 메인 화면이 보이는데요. 관심이 있는 분들은 화면의 여러 기능을 직접 사용해보세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%204.png&name=Untitled+4.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%204.png&name=Untitled+4.png)
        
        화면 상단을 보면 아직 제가 이메일 인증을 하지 않았다는 경고 문구가 보입니다. 이메일 인증까지 마쳐야 나중에 패키지를 업로드할 수 있습니다. 화면 상단의 'Do you need us to send it again?' 부분을 클릭하고, 회원가입할 때 입력했던 이메일로 가세요.
        
        6> 그럼 이렇게 인증 링크가 담긴 이메일이 와있을 겁니다. 인증 링크를 클릭하세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%205.png&name=Untitled+5.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%205.png&name=Untitled+5.png)
        
        7> 이제 이메일 인증이 완료되었습니다. Continue 버튼을 누르세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%206.png&name=Untitled+6.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%206.png&name=Untitled+6.png)
        
        8> 그럼 다시 메인 화면으로 돌아갑니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%207.png&name=Untitled+7.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%207.png&name=Untitled+7.png)
        
        자, 이제 제 패키지를 업로드해봅시다.
        
        # **2. 패키지 업로드(publish)**
        
        ## **(1) 패키지 업로드**
        
        1> 먼저 터미널을 실행합시다.(VScode의 내장 터미널을 사용하셔도 됩니다) 그리고
        
        ```
        npm login
        
        ```
        
        이라고 쓰고 엔터를 쳐보세요. 
        그럼 사용자 이름과 비밀번호를 입력할 수 있는데요. 방금 가입할 때 썼던 아이디와 비밀번호를 입력하고 엔터를 치세요. 비밀번호는 입력해도 입력된 것처럼 보이지 않으니까 그냥 입력하고 엔터를 치면 됩니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%208.png&name=Untitled+8.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%208.png&name=Untitled+8.png)
        
        2> 그럼 로그인이 완료됩니다. 그다음
        
        ```
        npm whoami
        
        ```
        
        라고 쓰고 실행해보면 지금 인증된 사용자가 누구인지 확인할 수 있습니다. codeit-teacher라고 잘 뜨죠? 여러분은 여러분의 사용자 이름이 뜰 겁니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%209.png&name=Untitled+9.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%209.png&name=Untitled+9.png)
        
        3> 자, 이제 바로 패키지를 npm 저장소에 공개할 수 있습니다.
        
        ```
        npm publish
        
        ```
        
        라는 명령어를 쓰고 엔터를 쳐보세요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2010.png&name=Untitled+10.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2010.png&name=Untitled+10.png)
        
        자, 이렇게 codeit_node_study@1.0.0이라는 패키지가 npm 저장소에 업로드되었습니다. 
        **이미 첫 번째로 codeit_node_study라는 패키지를 올린 수강생 분이 있다면 더 이상 같은 이름의 패키지는 업로드할 수 없습니다.** 따라서 package.json 파일에서 패키지 이름 부분을 여러분이 원하는 대로 다른 이름으로 수정하고 업로드해주세요!
        참고로 이렇게 **[패키지 이름]@[버전]** 형식의 명칭으로 하나의 고유한 패키지를 식별할 수 있다는 점을 기억하세요.
        
        4> 정말로 공개가 잘 되었는지 홈페이지에서 직접 확인해보겠습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2011.png&name=Untitled+11.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2011.png&name=Untitled+11.png)
        
        **codeit-node-study**라고 검색했더니 정말로 패키지가 잘 보이네요.
        
        자, 이렇게 간단하게 자신의 패키지를 업로드할 수 있다는 게 정말 신기하죠? 앞으로 자바스크립트와 Node.js 공부를 열심히 하고 여러분 나름의 멋진 패키지를 만들어서 이렇게 npm 공개 저장소에 올리는 걸 목표로 해보는 건 어떨까요?
        
        ## **(2) 패키지 버전 업데이트**
        
        하나의 패키지는 시간이 지날수록 발전합니다. 패키지에 새로운 코드와 파일들이 추가되거나 기존의 코드가 수정되는 작업이 반복되면서 말이죠. 이때 이전 노트에서 설명했던 것처럼 그 내용에 맞게 **Semantic Version**을 업데이트해줘야 하는데요. 이렇게 버전을 업데이트한 후에는 npm 저장소에도 새 버전의 패키지를 올려주면 좋겠죠? 그 방법을 한번 알아보겠습니다.
        
        1> 일단 현재 패키지가 업그레이드되었다고 가정하고 패키지 버전을 업데이트해보겠습니다. 패키지의 버전을 업데이트 하려면
        
        ```
        npm version
        
        ```
        
        이라고 쓰고 그 뒤에 새로운 버전을 써주면 됩니다. 저는 원래 1.0.0 버전이었으니까 패치 버전만 업데이트해서 1.0.1이라고 한번 써볼게요.
        
        그리고 나서는 쉽습니다. 그냥 또
        
        ```
        npm publish
        
        ```
        
        를 해주면 됩니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2012.png&name=Untitled+12.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2012.png&name=Untitled+12.png)
        
        그럼 마찬가지로 새로운 버전의 패키지도 npm 공개 저장소에 잘 업로드됩니다.
        
        2> 원래의 패키지 화면을 새로고침하고 **Versions** 라는 탭을 클릭해보면, 이때까지의 패키지 히스토리를 볼 수 있습니다. 이전에 올린 **1.0.0 버전**과 방금 올린 **1.0.1 버전**이 잘 보이죠?
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2013.png&name=Untitled+13.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2013.png&name=Untitled+13.png)
        
        3> 그다음 저는 버전을 **1.0.0 → 1.0.1 → 1.1.0 → 2.0.1** 로 계속 올리고 매번 publish를 해봤는데요. 그리고 나서 다시 확인해보면 아래 이미지처럼 각 버전이 모두 잘 보입니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2014.png&name=Untitled+14.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2014.png&name=Untitled+14.png)
        
        ## **(3) 공개된 패키지 다시 내리기**
        
        1> 만약 공개된 패키지를 다시 npm 저장소에서 없애고 싶다면 어떻게 해야 할까요? 만약 특정 버전의 패키지만 없애고 싶다면
        
        ```
        npm unpublish [패키지 이름]@[버전]
        
        ```
        
        형식의 명령어를 입력해주면 됩니다. codeit_node_study 패키지 1.0.1 버전을 npm 저장소에서 없애볼게요.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2015.png&name=Untitled+15.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2015.png&name=Untitled+15.png)
        
        그다음 확인해보면(반영되는데 시간이 좀 걸릴 수도 있습니다)
        
        2> 1.0.1 버전만 깔끔하게 사라진 것을 확인할 수 있습니다.
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2016.png&name=Untitled+16.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2016.png&name=Untitled+16.png)
        
        3> 그렇다면 만약 모든 버전의 패키지를, 없애고 싶다면 어떻게 해야 할까요? 그럴 때는
        
        ```
        npm unpublish [패키지 이름] --force
        
        ```
        
        라고 쓰면 됩니다. 패키지의 모든 버전을 npm 저장소에서 삭제하는 건 위험한 작업이기 때문에 **--force**(강제로 실행하다) 옵션을 줘야 실행할 수 있는데요. 실행해보면,
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2017.png&name=Untitled+17.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2017.png&name=Untitled+17.png)
        
        "I sure hope you know what you are doing(당신이 지금 무슨 작업을 하는지를 알고 있기를 바랍니다)"이라는 경고 문구가 뜨네요.
        
        다시 웹 페이지에서 확인해보면
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2018.png&name=Untitled+18.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3739&directory=Untitled%2018.png&name=Untitled+18.png)
        
        같은 URL을 새로고침했는데 이제는 **codeit_node_study 패키지가 존재하지 않는다고 뜨네요.** 공개한 패키지를 삭제하는 것도 어렵지 않죠?
        
        자, 이때까지
        
        - 나의 패키지를 npm 저장소에 업로드하는 법
        - 업데이트된 패키지들도 추가로 업로드하는 법
        - 업로드한 패키지를 삭제하는 방법을 배웠는데요.
        
        만약 나중에 여러분이 꽤 괜찮은 패키지를 만들게 된다면, npm 저장소에 올리고 주변 사람들, 그리고 코드잇에도 꼭 알려주세요~!
        
    - package.json VS package-lock.json
        
        
        패키지를 공유할 때 용량문제가 있어서 node_modules 디렉토리를 공유하지 않는다.
        
        이걸 매번 공유하느니 package.json 파일만 공유하여
        
        npm install 명령어로 dependencies 패키지들을 설치하도록하는게 낫겟지
        
        그런데 version range syntax 가 안맞으면 문제가 되는 경우가 있는데
        
        dependency 차이를 없애고 싶다면?
        
        - package-lock.json (처음 패키지 설치했을 때 생겼던 파일)
        package.json (npm init 명령어를 사용해서 디렉토리를 패키지로 만들때 생긴 파일)
        
        package-lock.json 파일에는 dependencies 필드에 현재 패키지 안에 어떤 패키지들이 설치되어있는지 정보가 담겨있음 
        
        ( “실제로 설치된” 패키지 이름과 정확한 버젼들을 볼 수 있다)
        
        package-json 파일도 마찬가지로 dependencies 필드가 있고 여기에 어떤 패키지들이 설치되어야 하는지 정보가 담겨있음
        
        (”Version Range Syntax 가 있을 수 있음. 특정 패키지의 특정 버전이 아니라 필요한 다른 패키지들의 ‘범위’ 가 나와있음)
        
        **곧, package-lock.json 파일의 dependencies 를 보고 특정 버전의 패키지들을 정확히 동일하게 설치하는 것이다. 그러면 동일한 node_modules 디렉토리를 갖겠지?**
        
        그러니까 패키지를 공유할 때는 이 package-lock.json 도 공유해야된다
        
        (정확히 똑같지 않아도 될 땐 package.json 만 공유하고)
        
    - 패키지 간 의존 관계의 위험성
        
        이때까지 하나의 패키지는 보통 스스로 혼자 동작하는 것이 아니라, 많은 dependencies에 의존해서 동작한다는 사실을 배웠습니다. 
        그리고 Semantic Version과 Version Range Syntax를 기반으로 이러한 시스템이 유지된다는 것도 배웠는데요. 
        Node.js 개발을 하다 보면 현재 작업 중이 디렉토리(패키지) 내에서, 외부의 패키지 몇 개만 **npm install [패키지명]** 형식으로 설치해도 곧장 그에 딸린 수십, 수백 개의 패키지들이 설치되는 것을 발견하게 될 겁니다.
        
        그런데 이렇게 하나의 패키지가 다른 패키지들에 의존하고, 그것들이 또 다른 패키지들에 의존하는 모습은 약간의 위험성을 갖고 있기도 합니다. 어떤 문제들이 있는지 한번 살펴봅시다.
        
        # **1. 악성코드 문제**
        
        첫 번째로 악성 코드 문제가 있습니다. 그러니까 내 패키지가 의존하는 수많은 하위 패키지 중에 악성코드가 있을 수도 있다는 뜻이죠. 실제로 2017년에는 cross-env라는 유명 패키지와 이름이 비슷한 crossenv라는 패키지에 악성 코드가 들어 있는 경우가 발견된 적도 있습니다.[[1]](https://www.codeit.kr/learn/3741#fn1) 사용자들이 패키지를 설치할 때 오타를 별로 신경 쓰지 않고 패키지를 설치해버리는 취약점을 공격한 일명 'typo-squatting' 기법을 사용한 경우였는데요.
        
        이 뿐만 아니라 2018년에는 Event-Stream이라는 유명 패키지가 의존하던 Flatmap-Stream이라는 패키지에 비트코인 관련 악성 코드가 포함된 사건도 있었고,[[2]](https://www.codeit.kr/learn/3741#fn2) 2020년에는 유닉스 시스템의 중요 정보를 빼가는 악성 패키지가 발견되는 사건도 있었습니다.[[3]](https://www.codeit.kr/learn/3741#fn3)
        
        내가 사용하는 패키지 중에 이런 악성 코드들이 있다고 상상해보면 정말 무섭죠? 물론 패키지들의 보안 검사를 위해 npm 커뮤니티에서 많은 노력을 하고는 있지만, 특정 패키지, 그리고 그것이 의존하는 패키지들이 사용해도 괜찮은 것인지 확인하는 것은 본질적으로 그것을 사용해서 서비스를 만드는 개발자의 책임입니다. 모든 패키지를 본인이 직접 검사하는 것은 현실적으로 어렵겠지만 악성 코드가 있는 패키지를 설치하지 않으려면, 되도록 누구나 알 정도로 공신력있는 패키지들만을 골라서 사용하는 것이 좋습니다.
        
        # **2. 패키지 내 코드의 취약점 문제**
        
        두 번째는 취약점 문제입니다. 어떤 패키지들의 코드에는 보안 측면에서 취약한 부분이 있을 수 있습니다. npm 측과 각종 보안 회사들은 어떤 패키지의 어떤 점이 취약하다고 주기적으로 발표를 하는데요. 이 문제에 관해 우리가 할 수 있는 것은 다음과 같습니다.
        
        ## **(1) npm outdated, npm update 정기적으로 실행하기**
        
        먼저, 현재 작업 중인 패키지 안에서 **npm outdated**, **npm update** 라는 명령어를 자주 실행해주는 겁니다. **npm outdated**는 현재 패키지에 설치된 하위 패키지들 중에 버전이 최신이 아닌 것들이 무엇이 있는지 보여주는 명령어입니다. 그리고 **npm update**는 현재 자신의 패키지에 설치된 모든 패키지들을 최신 패키지로 업데이트해주는 명령어이고요.
        
        본인의 패키지 안에서 npm outdated로 오래된 패키지들이 많지는 않은지 확인해주고, npm update로 이것들을 최신 패키지로 업데이트해주는 작업을 정기적으로 수행해주면 좋습니다. 참고로 npm update는 package.json 파일의 dependencies 필드에 표시된 해당 패키지의 Version Range Syntax가 허용하는 범위 내에서만 업데이트를 해줍니다. 현재 설치된 버전이 1.5.2고, 최신 버전은 3.0.0인 패키지가 있다고 해도 이 패키지에 의존 중인 패키지의 package.json 파일에서 dependencies 필드에 ~1.8.3 이라고 써있다면 1.9.0 미만의 최신 버전까지로만 업데이트해주는 겁니다.
        
        어쨌든 최신 버전의 패키지들을 사용할수록 일반적으로 보안상 더 안전하기 때문에 위 작업을 주기적으로 실행해주는 게 좋습니다. 이때 일부 패키지의 경우, 최신 버전으로 업데이트하기 전에 별도의 검토가 필요해서 모든 패키지를 최신의 것으로 바꾸면 안 되는 경우에는
        
        ```
        npm update [패키지명]
        
        ```
        
        을 실행해서 원하는 패키지만 업데이트해줘도 됩니다. 만약 최신보다 약간 이전의 버전을 원하면
        
        ```
        npm update [패키지명]@[버전]
        
        ```
        
        이런 식으로 특정 버전을 지정해주고 실행하면 됩니다.
        
        ## **(2) npm audit, npm audit fix으로 취약점 점검하기**
        
        패키지 내의 보안을 유지하는 또 다른 방법은 **npm audit**이라는 커맨드를 사용하는 건데요. 현재 자신의 패키지 안에서 npm audit이라는 커맨드를 실행하면, npm이 현재 설치된 패키지들의 이름과 버전을 보고, 발표된 취약점이 있는 것들은 그 정보를 출력해줍니다. 저도 제 패키지에서 npm audit을 실행해봤더니
        
        [https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3741&directory=Untitled.png&name=Untitled.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=3741&directory=Untitled.png&name=Untitled.png)
        
        이렇게 취약점 하나가 발견되었습니다. 이때 **npm install fix**라는 명령어를 실행하면 npm이 Version Range Syntax를 준수하면서도, 취약점이 해결된 더 최신 버전의 패키지를 자동으로 설치해줍니다. 하지만 이 npm install fix 만으로는 문제를 해결하지 못하는 경우도 있는데요. 이럴 때는 More info에 있는 URL로 들어가서 필요한 해결 조치를 보고 직접 수행해주면 됩니다.
        
        방금 말한 방법들을 사용하면 보안상 취약한 패키지들을 사용하게 될 가능성은 작아지겠죠?
        
        # **3. 패키지의 가용성(Availability) 문제**
        
        세 번째로 문제점은 사용 중이던 패키지가 갑자기 사라져버리거나 관리되지 않고 방치될 수도 있다는 점입니다. 실제로 2016년에는 left-pad라고 하는 패키지의 주인이 npm 저장소에서 그 패키지를 삭제해버린 사건이 있었습니다.[[4]](https://www.codeit.kr/learn/3741#fn4) 이 때문에 당시 left-pad에 의존하고 있던, React나 Babel 같은 대형 프로젝트들에도 큰 문제가 발생했었는데요. 다행히 이 문제는 잘 해결되었지만, 이 사건은 당시 수많은 패키지들의 의존 생태계가 단 한 순간에 무너져버릴 수도 있다는 공포감을 개발자들에게 심어주었습니다. 그리고 단순한 기능 정도는 패키지를 굳이 쓰지 말자는 의식의 전환을 가져다주기도 했죠. 왜냐하면 당시 left-pad의 코드는 아래와 같이 단순한 코드였기 때문입니다.
        
        ```
        module.exports = leftpad;
        
        function leftpad (str, len, ch) {
          str = String(str);
          var i = -1;
          if (!ch && ch !== 0) ch = ' ';
          len = len - str.length;
          while (++i < len) {
            str = ch + str;
         }
          return str;
        }
        
        ```
        
        이런 작은 코드 조각이 수많은 회사들을 당황하게 만든 겁니다. 놀라운 사실이죠?
        
        현재, npm 저장소에 한 번 올린 패키지는, 올리고 나서 72시간이 지나면 함부로 삭제할 수 없도록 되어 있습니다. 그래서 이제 그런 문제는 발생할 수 없겠지만 내가 사용하는 패키지가 앞으로도 잘 관리될 패키지인지를 확인하는 것은 여전히 중요합니다. 이 부분은 패키지의 인기도, 패키지를 관리하는 주체 등을 보고 스스로 잘 판단해야겠죠? 
        
        자, 이때까지 다른 패키지들에 의존함으로써 발생할 수 있는 문제들을 살펴봤습니다. 어떤 플랫폼도 마찬가지지만, 특히 Node.js의 패키지 생태계는 다양하고 유용한 패키지들이 아주 많이 존재한다는 점이 매력적입니다. 하지만 이렇게 다양한 패키지들을 자유롭게 사용하는 편리함을 누리는 만큼, 그 대가로 우리는 사용하는 패키지에 대해
        
        - 이상한 코드는 없는지,
        - 외부의 공격에 취약한 부분은 없는지,
        - 앞으로도 꾸준한 업데이트가 이루어질지를
        
        잘 고민하고 사용해야 합니다. 특정 분야에서 사실상 표준(de facto standard)처럼 존재하는 패키지가 있는 경우라면 상관없지만, 그렇지 않은 경우에 어떤 패키지를 사용하려고 한다면, 방금 위에서 설명한 기준들을 충족하는지 잘 판단하고 사용 여부를 결정하세요.